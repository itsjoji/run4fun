<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>run4fun - Optimized</title>

<style>
  :root {
    --bg-color: #4b8ce6;
    --text-font: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    --display-font: "Georgia", serif;
    --monospace: monospace;
  }

  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg-color);
    overflow: hidden;
    font-family: var(--text-font);
    touch-action: none; /* Prevents pinch-zoom/scroll on mobile */
  }

  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }

  /* UI Overlays */
  .overlay-text {
    position: absolute;
    pointer-events: none;
    color: white;
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0,0,0,0.6);
    z-index: 10;
  }

  #centerOverlay {
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 30px;
    text-align: center;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    transition: opacity 0.3s ease;
    width: 100%;
  }

  #scoreBox {
    top: 20px;
    left: 20px;
    font-size: 24px;
    font-family: var(--monospace);
  }

  #starBox {
    top: 50px;
    left: 20px;
    color: #ffd700;
    font-size: 20px;
    font-family: var(--monospace);
  }

  /* Death Screen */
  #deathScreen {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,0,0.60);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.8s ease-out;
    font-family: var(--display-font);
    z-index: 20;
  }

  #deathTitle {
    font-size: 80px;
    font-weight: 700;
    color: #8C0000;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 10px rgba(0,0,0,0.8);
    letter-spacing: 15px;
    margin-bottom: 20px;
    position: relative;
    top: -30px;
    padding-left: 15px;
    text-align: center;
  }

  #deathSubtext {
    font-size: 24px;
    color: #e0d165;
    text-shadow: 0 1px 2px #000;
    letter-spacing: 2px;
    position: relative;
    top: -20px;
    text-align: center;
  }

  /* Mobile Controls */
  #touchButton {
    position: absolute;
    right: 20px;
    bottom: 20px;
    width: 75px;
    height: 75px;
    border-radius: 50%;
    background: #ffd42a;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    user-select: none;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    cursor: pointer;
    z-index: 15;
    font-size: 24px;
  }

  @media (min-width: 700px) {
    #touchButton { display: none; }
  }
  @media (max-width: 600px) {
      #deathTitle { font-size: 50px; letter-spacing: 5px; }
  }
</style>
</head>

<body>
<canvas id="game"></canvas>

<div id="scoreBox" class="overlay-text">SCORE: 0</div>
<div id="starBox" class="overlay-text">STARS: 0</div> 
<div id="centerOverlay" class="overlay-text">Tap / Space to Start</div>

<div id="deathScreen">
    <div id="deathTitle">YOU DIED</div>
    <div id="deathSubtext"></div> 
</div>

<div id="touchButton">â–²</div>

<script>
(() => {
    // --- CONSTANTS & CONFIGURATION ---
    const CONSTANTS = {
        PHYSICS: {
            GRAVITY: 1800,
            JUMP_FORCE: -760,
            SPEED_START: 260,
            SPEED_MAX: 900,
            SPEED_INC: 10, 
            SCORE_MULTIPLIER: 0.15
        },
        DIMENSIONS: {
            PLAYER_SIZE: 36,
            PLATFORM_HEIGHT: 24,
            STAR_SIZE: 16,
            GROUND_OFFSET: 140, 
            DEATH_ZONE: 100    
        },
        GENERATION: {
            PLATFORM_GAP: { MIN: 100, MAX: 220 },
            PLATFORM_WIDTH: { MIN: 260, MAX: 480 },
            PLATFORM_Y_VAR: { MIN: -40, MAX: 80 },
            STAR_CHANCE: 0.3,
            GAP_STAR_CHANCE: 0.1,
            CYCLE_MAX_SCORE: 7000,
            MIDNIGHT_SCORE: 6700
        },
        COLORS: {
            PLATFORM_BASE: "#5d4037",
            PLATFORM_TOP: "#4caf50",
            PLAYER: "#ffd42a",
            STAR: "#ffd700",
            BIRDS_COMMON: ["#f0f8ff", "#808080", "#333333"],
            BIRDS_RARE: ["#aeea00", "#ff0055", "#00ccff"]
        }
    };

    // --- UTILITIES ---
    class MathUtils {
        static rand(a, b) { return Math.random() * (b - a) + a; }
        static clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        static lerp(a, b, t) { return a + (b - a) * t; }
        
        static lerpColor(a, b, amount) {
            const ah = parseInt(a.replace('#', '0x'), 16),
                  ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff,
                  bh = parseInt(b.replace('#', '0x'), 16),
                  br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff,
                  rr = ar + amount * (br - ar),
                  rg = ag + amount * (bg - ag),
                  rb = ab + amount * (bb - ab);
            return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1).toUpperCase();
        }

        static interpolateX(x1, y1, x2, y2, thresholdY) {
            const diffY = y2 - y1;
            if (Math.abs(diffY) < 0.001) return x1;
            return x1 + (x2 - x1) * ((thresholdY - y1) / diffY);
        }

        static checkAABB(r1, r2) {
            return r1.x < r2.x + r2.w &&
                   r1.x + r1.w > r2.x &&
                   r1.y < r2.y + r2.h &&
                   r1.y + r1.h > r2.y;
        }
    }

    // --- ENTITIES ---

    class Player {
        constructor(groundY) {
            this.size = CONSTANTS.DIMENSIONS.PLAYER_SIZE;
            this.x = 150;
            this.y = groundY - this.size;
            this.vy = 0;
            this.jumpsLeft = 2;
            this.onGround = true; 
            this.alive = true;
        }

        update(dt, platforms, gravity) {
            if (!this.alive) return;

            this.vy += gravity * dt;
            this.y += this.vy * dt;
            this.onGround = false;

            const playerBottom = this.y + this.size;
            const playerRight = this.x + this.size;

            for (const p of platforms) {
                if (playerRight > p.x && this.x < p.x + p.w) {
                    const oldBottom = playerBottom - (this.vy * dt);
                    if (oldBottom <= p.y + 5 && playerBottom >= p.y && this.vy >= 0) {
                        this.y = p.y - this.size;
                        this.vy = 0;
                        this.onGround = true;
                        this.jumpsLeft = 2;
                    }
                }
            }
        }

        jump() {
            if (this.jumpsLeft > 0) {
                this.vy = CONSTANTS.PHYSICS.JUMP_FORCE;
                this.jumpsLeft--;
            }
        }
    }

    class TerrainGenerator {
        static generateJaggedLine(x1, y, x2, noiseAmount, step) {
            let points = [];
            points.push({ x: x1, y: y + MathUtils.rand(-noiseAmount, noiseAmount) });
            let currentX = x1;
            while (currentX < x2) {
                currentX += step;
                if (currentX < x2) points.push({ x: currentX, y: y + MathUtils.rand(-noiseAmount, noiseAmount) });
            }
            points.push({ x: x2, y: y + MathUtils.rand(-noiseAmount, noiseAmount) });
            return points;
        }

        static generatePoly(width, minScreenY, maxScreenY, startScreenY, isHills) {
            let points = [];
            let steps = isHills ? 4 : 8;
            let segW = width / steps;
            let currentY = startScreenY !== undefined ? startScreenY : MathUtils.rand(minScreenY, maxScreenY);
            
            points.push({x:0, y:currentY});
            for(let i=1; i<=steps; i++){
                let change = isHills ? MathUtils.rand(-50, 50) : MathUtils.rand(-100, 100);
                currentY = MathUtils.clamp(currentY + change, minScreenY, maxScreenY);
                points.push({ x: i*segW, y: currentY });
            }
            return points;
        }

        static initializeSnow(mountain, worldHeight) {
            const threshold = worldHeight * 0.45;
            if (!mountain.points.some(p => p.y < threshold)) return null;
            let allSnow = [];
            let curProfile = [];
            let building = false;
            let startX = -1;

            for(let i = 0; i < mountain.points.length - 1; i++){
                let p1 = mountain.points[i], p2 = mountain.points[i+1];
                const segmentAbove = p1.y < threshold || p2.y < threshold;

                if (!building && segmentAbove) {
                    building = true;
                    curProfile = [];
                    startX = (p1.y >= threshold) ? MathUtils.interpolateX(p1.x, p1.y, p2.x, p2.y, threshold) : p1.x;
                }
                if (building) {
                    const steps = 5, stepX = (p2.x - p1.x)/steps;
                    for(let j=0; j<=steps; j++) {
                        let cX = p1.x + j*stepX, cY = p1.y + (p2.y - p1.y)*(j/steps);
                        if (cY < threshold) curProfile.push({x: cX, y: cY});
                    }
                    if (p1.y < threshold && p2.y >= threshold) {
                        building = false;
                        let endX = MathUtils.interpolateX(p1.x, p1.y, p2.x, p2.y, threshold);
                        allSnow.push({ snowProfile: curProfile, jaggedBase: this.generateJaggedLine(startX, threshold, endX, 10, 10) });
                        curProfile = [];
                    }
                }
            }
            if (building && curProfile.length > 0) {
                let endX = mountain.points[mountain.points.length - 1].x;
                allSnow.push({ snowProfile: curProfile, jaggedBase: this.generateJaggedLine(startX, threshold, endX, 10, 10) });
            }
            return allSnow.length ? allSnow : null;
        }
    }

    class DayNightCycle {
        constructor() {
             this.SKY_COLORS = [
                { p: 0.0, top: "#004e92", bottom: "#4ca1af" },
                { p: 0.2, top: "#4a90e2", bottom: "#8bd0f7" },
                { p: 0.45, top: "#ff6b00", bottom: "#ffb457" },
                { p: 0.6, top: "#3a2a6b", bottom: "#1a1a4a" },
                { p: 0.8, top: "#000033", bottom: "#1e3a8a" },
                { p: 1.0, top: "#000000", bottom: "#0a0a2a" }
            ];
            this.MTN_COLORS = [
                { p: 0.0, far: "#2c3e50", near: "#34495e", hills: "#455a64" },
                { p: 0.45, far: "#5a3a2a", near: "#6d4e3e", hills: "#806653" },
                { p: 0.6, far: "#2d1c4b", near: "#3a2a6b", hills: "#4b3a8a" },
                { p: 0.8, far: "#1a1a2e", near: "#282a4a", hills: "#3e4064" },
                { p: 1.0, far: "#00000a", near: "#0a0a2a", hills: "#1a1a3a" }
            ];
        }

        getColors(score) {
            let p = (score % CONSTANTS.GENERATION.CYCLE_MAX_SCORE) / CONSTANTS.GENERATION.CYCLE_MAX_SCORE;
            const offset = CONSTANTS.GENERATION.MIDNIGHT_SCORE / CONSTANTS.GENERATION.CYCLE_MAX_SCORE;
            const pShifted = (p + (1 - offset)) % 1;

            const getLerped = (arr) => {
                let i = 0;
                while(i < arr.length - 1 && pShifted > arr[i+1].p) i++;
                const start = arr[i], end = arr[Math.min(arr.length-1, i+1)];
                const t = (pShifted - start.p) / (end.p - start.p);
                return { start, end, t };
            };

            const sky = getLerped(this.SKY_COLORS);
            const mtn = getLerped(this.MTN_COLORS);

            return {
                skyTop: MathUtils.lerpColor(sky.start.top, sky.end.top, sky.t),
                skyBottom: MathUtils.lerpColor(sky.start.bottom, sky.end.bottom, sky.t),
                far: MathUtils.lerpColor(mtn.start.far, mtn.end.far, mtn.t),
                near: MathUtils.lerpColor(mtn.start.near, mtn.end.near, mtn.t),
                hills: MathUtils.lerpColor(mtn.start.hills, mtn.end.hills, mtn.t),
                pShifted: pShifted
            };
        }
    }

    // --- GAME ENGINE ---

    class Game {
        constructor() {
            this.canvas = document.getElementById("game");
            this.ctx = this.canvas.getContext("2d");
            this.ui = {
                score: document.getElementById("scoreBox"),
                stars: document.getElementById("starBox"),
                overlay: document.getElementById("centerOverlay"),
                death: document.getElementById("deathScreen"),
                deathSub: document.getElementById("deathSubtext"),
                btn: document.getElementById("touchButton")
            };
            
            this.cycle = new DayNightCycle();
            this.DPR = 1;
            
            this.resize = this.resize.bind(this);
            this.loop = this.loop.bind(this);
            this.handleInput = this.handleInput.bind(this);
            this.openShop = this.openShop.bind(this);

            window.addEventListener("resize", this.resize);
            window.addEventListener("keydown", this.handleInput);
            window.addEventListener("pointerdown", () => this.handleInput({ type: 'pointer' }));
            this.ui.btn.addEventListener("pointerdown", (e) => { e.stopPropagation(); this.handleInput({ type: 'pointer' }); });

            this.initInternalDimensions(); // Initial size calculation
            this.reset();
            
            this.lastTime = performance.now();
            this.gameTime = 0;
            requestAnimationFrame(this.loop);
        }

        get groundY() { return this.height - CONSTANTS.DIMENSIONS.GROUND_OFFSET; }

        // Sets up dimensions without shifting entities (used on boot)
        initInternalDimensions() {
            this.DPR = window.devicePixelRatio || 1;
            this.canvas.width = window.innerWidth * this.DPR;
            this.canvas.height = window.innerHeight * this.DPR;
            this.ctx.setTransform(this.DPR, 0, 0, this.DPR, 0, 0);
            this.width = this.canvas.width / this.DPR;
            this.height = this.canvas.height / this.DPR;
        }

        // Smart resize: adjusts entity positions to keep them relative to ground
        resize() {
            const oldHeight = this.height;
            this.initInternalDimensions(); // Update width/height
            const newHeight = this.height;
            
            const deltaY = newHeight - oldHeight;

            // Shift World Entities so they don't jump or float
            if (this.platforms) this.platforms.forEach(p => p.y += deltaY);
            if (this.stars) this.stars.forEach(s => s.y += deltaY);
            if (this.player) this.player.y += deltaY;
            
            // Mountains need complex shifting or they stretch. 
            // Simple shift implies moving the points down.
            const shiftMtn = (list) => {
                if(!list) return;
                list.forEach(m => {
                    m.points.forEach(p => p.y += deltaY);
                    if(m.snow) {
                        m.snow.forEach(s => {
                            s.snowProfile.forEach(sp => sp.y += deltaY);
                            s.jaggedBase.forEach(jb => jb.y += deltaY);
                        });
                    }
                });
            };
            shiftMtn(this.mountains.far);
            shiftMtn(this.mountains.near);
            shiftMtn(this.mountains.hills);
        }

        reset() {
            this.player = new Player(this.groundY);
            this.speed = CONSTANTS.PHYSICS.SPEED_START;
            this.score = 0;
            this.starsCollected = 0;
            this.startDelay = true;
            
            this.platforms = [];
            this.stars = [];
            this.birds = [];
            this.clouds = [];
            this.mountains = { far: [], near: [], hills: [] };
            
            this.ui.score.innerText = "SCORE: 0";
            this.ui.stars.innerText = "STARS: 0";
            this.ui.deathSub.innerText = "";
            this.ui.overlay.style.opacity = 1;
            this.ui.death.style.opacity = 0;
            this.ui.death.style.pointerEvents = "none";

            this.initWorld();
        }

        initWorld() {
            // Init Mountains
            const createLayer = (arr, w, minH, maxH, speed, isHills) => {
                const count = Math.ceil(this.width / w) + 2;
                let lastY = MathUtils.rand(minH, maxH);
                for(let i=0; i<count; i++) {
                    let pts = TerrainGenerator.generatePoly(w, minH, maxH, lastY, isHills);
                    lastY = pts[pts.length-1].y;
                    let m = { x: i*w, w: w, points: pts, speed: speed };
                    if(speed === 0.15) m.snow = TerrainGenerator.initializeSnow(m, this.height); 
                    arr.push(m);
                }
            };

            const H = this.height;
            createLayer(this.mountains.far, 800, H-650, H-400, 0.15, false);
            createLayer(this.mountains.near, 600, H-450, H-250, 0.3, false);
            createLayer(this.mountains.hills, 450, H-180, H-100, 0.6, true);

            // Init Clouds
            for(let i=0; i<12; i++) this.clouds.push(this.createCloud());

            // Init Birds
            for(let i=0; i<3; i++) this.spawnBird();

            // Init Platforms
            let initPlat = { x: this.player.x - 60, y: this.groundY, w: 500, h: CONSTANTS.DIMENSIONS.PLATFORM_HEIGHT };
            this.platforms.push(initPlat);
            
            let cx = initPlat.x + initPlat.w + 60;
            for(let i=0; i<6; i++) cx = this.addPlatform(cx, i);
        }

        createCloud() {
            return {
                x: MathUtils.rand(0, this.width),
                y: MathUtils.rand(20, this.height * 0.45),
                w: MathUtils.rand(80, 160),
                h: MathUtils.rand(20, 50),
                opacity: MathUtils.rand(0.4, 0.8),
                speed: MathUtils.rand(10, 30)
            };
        }

        spawnBird() {
            let isRare = Math.random() < 0.05;
            let pool = isRare ? CONSTANTS.COLORS.BIRDS_RARE : CONSTANTS.COLORS.BIRDS_COMMON;
            this.birds.push({
                x: this.width + MathUtils.rand(50, 350),
                y: MathUtils.rand(this.height*0.35, this.height*0.55),
                speed: MathUtils.rand(90, 140),
                flapTimer: 0,
                frame: 0,
                color: pool[Math.floor(Math.random() * pool.length)]
            });
        }

        addPlatform(startX, index) {
            const G = CONSTANTS.GENERATION;
            let gap = MathUtils.rand(G.PLATFORM_GAP.MIN, G.PLATFORM_GAP.MAX);
            let w = MathUtils.rand(G.PLATFORM_WIDTH.MIN, G.PLATFORM_WIDTH.MAX);
            // Ensure Y is clamped correctly within new height boundaries
            let lastY = this.platforms.length ? this.platforms[this.platforms.length-1].y : this.groundY;
            let y = MathUtils.clamp(lastY + MathUtils.rand(G.PLATFORM_Y_VAR.MIN, G.PLATFORM_Y_VAR.MAX), 70, this.height - 80);
            
            let p = { x: startX + gap, y, w, h: CONSTANTS.DIMENSIONS.PLATFORM_HEIGHT };

            if (index > 0 && Math.random() < G.GAP_STAR_CHANCE) {
                let prev = this.platforms[this.platforms.length-1];
                let midY = (prev.y + p.y) / 2;
                let starY = MathUtils.clamp(midY - 80, this.height * 0.1, this.height - 200);
                this.stars.push({ x: prev.x + prev.w + gap/2, y: starY, size: CONSTANTS.DIMENSIONS.STAR_SIZE, rotation: 0, collected: false });
            }

            this.platforms.push(p);

            if (Math.random() < G.STAR_CHANCE) {
                this.stars.push({ x: p.x + p.w/2, y: p.y - 18, size: CONSTANTS.DIMENSIONS.STAR_SIZE, rotation: MathUtils.rand(0, Math.PI*2), collected: false });
            }
            return p.x + p.w;
        }

        handleInput(e) {
            if (e.code === "KeyH") { e.preventDefault(); this.openShop(); return; }
            
            if (e.type === 'pointer' || ["Space", "KeyW"].includes(e.code)) {
                if (e.preventDefault) e.preventDefault();
                
                if (!this.player.alive) {
                    this.reset();
                    return;
                }
                if (this.startDelay) {
                    this.startDelay = false;
                    this.ui.overlay.style.opacity = 0;
                    this.player.jumpsLeft = 2;
                    return;
                }
                this.player.jump();
            }
        }

        openShop() {
            if (this.player.alive) {
                console.log(`--- HAT SHOP OPENED ---\nCurrent Stars: ${this.starsCollected}\n-----------------------`);
            }
        }

        update(dt) {
            if (!this.player.alive) return;

            if (!this.startDelay) {
                this.speed = Math.min(CONSTANTS.PHYSICS.SPEED_MAX, this.speed + dt * CONSTANTS.PHYSICS.SPEED_INC);
                this.score += (this.speed * dt) * CONSTANTS.PHYSICS.SCORE_MULTIPLIER;
                this.ui.score.innerText = "SCORE: " + Math.floor(this.score);
            }

            const scroll = this.startDelay ? 0 : this.speed * dt;
            const H = this.height;
            
            // Mountains
            const updateLayer = (list, w, speed, minH, maxH, isFar) => {
                for(let m of list) m.x -= this.speed * speed * dt;
                list = list.filter(m => m.x + m.w > 0);
                const last = list[list.length-1];
                if(last.x + last.w < this.width + w * 0.25) {
                    let startY = last.points[last.points.length-1].y;
                    let pts = TerrainGenerator.generatePoly(w, minH, maxH, startY, speed === 0.6);
                    let m = { x: last.x + last.w - 4, w: w, points: pts, speed: speed };
                    if(isFar) m.snow = TerrainGenerator.initializeSnow(m, H);
                    list.push(m);
                }
                return list;
            };

            this.mountains.far = updateLayer(this.mountains.far, 800, 0.15, H-650, H-400, true);
            this.mountains.near = updateLayer(this.mountains.near, 600, 0.3, H-450, H-250, false);
            this.mountains.hills = updateLayer(this.mountains.hills, 450, 0.6, H-180, H-100, false);

            // Clouds
            for(let c of this.clouds) {
                c.x -= (this.startDelay ? 0 : this.speed * 0.12 + c.speed * 0.02) * dt;
                if(c.x + c.w < -100) c.x = this.width + 100;
            }

            // Birds
            for(let b of this.birds) {
                b.x -= b.speed * dt;
                b.flapTimer += dt * 6;
                b.frame = Math.floor(b.flapTimer) % 2;
            }
            this.birds = this.birds.filter(b => b.x > -200);
            if(this.birds.length < 4) this.spawnBird();

            // Platforms & Stars
            for(let p of this.platforms) p.x -= scroll;
            
            for(let s of this.stars) {
                s.x -= scroll;
                s.rotation += dt * 3;
                let starBox = { x: s.x - s.size/2, y: s.y - s.size/2, w: s.size, h: s.size };
                let playerBox = { x: this.player.x, y: this.player.y, w: this.player.size, h: this.player.size };
                if (MathUtils.checkAABB(playerBox, starBox)) {
                    this.starsCollected++;
                    this.ui.stars.innerText = "STARS: " + this.starsCollected;
                    s.collected = true;
                }
            }
            this.stars = this.stars.filter(s => s.x + s.size > -100 && !s.collected);
            this.platforms = this.platforms.filter(p => p.x + p.w > -300);

            let rightMost = -999;
            for(let p of this.platforms) rightMost = Math.max(rightMost, p.x + p.w);
            while(rightMost < this.width + 600) {
                rightMost = this.addPlatform(rightMost, this.platforms.length);
            }

            // Player Physics
            if (!this.startDelay) {
                this.player.update(dt, this.platforms, CONSTANTS.PHYSICS.GRAVITY);
            }

            if (this.player.y > this.height + CONSTANTS.DIMENSIONS.DEATH_ZONE) {
                this.player.alive = false;
                this.ui.death.style.opacity = 1;
                this.ui.death.style.pointerEvents = "auto";
                this.ui.deathSub.innerText = "Tap/Space to Restart";
            }
        }

        draw() {
            const ctx = this.ctx;
            const W = this.width;
            const H = this.height;
            const colors = this.cycle.getColors(this.score);

            // 1. Sky
            let grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, colors.skyTop);
            grad.addColorStop(0.5, colors.skyBottom);
            grad.addColorStop(1, MathUtils.lerpColor(colors.skyBottom, "#ffffff", 0.5));
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // 2. Celestial
            this.drawCelestial(colors.pShifted);

            // 3. Clouds
            const cloudAlpha = MathUtils.lerp(1.0, 0.2, colors.pShifted > 0.5 ? (colors.pShifted - 0.5) * 2 : 0);
            for(let c of this.clouds) {
                ctx.fillStyle = `rgba(255,255,255,${c.opacity * cloudAlpha})`;
                ctx.fillRect(c.x, c.y, c.w, c.h);
                ctx.fillRect(c.x + 20, c.y - 15, c.w - 40, 20);
            }

            // 4. Mountains
            const drawMtn = (list, color, hasSnow) => {
                for(let m of list) {
                    let rX = Math.round(m.x);
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(rX, H);
                    ctx.lineTo(rX + m.points[0].x, m.points[0].y);
                    for(let i=1; i<m.points.length; i++) ctx.lineTo(rX + m.points[i].x, m.points[i].y);
                    ctx.lineTo(rX + m.w, H);
                    ctx.fill();

                    if(hasSnow && m.snow) {
                        ctx.fillStyle = "white";
                        for(let s of m.snow) {
                            ctx.beginPath();
                            ctx.moveTo(rX + s.jaggedBase[0].x, s.jaggedBase[0].y);
                            for(let p of s.snowProfile) ctx.lineTo(rX + p.x, p.y);
                            for(let i=s.jaggedBase.length-1; i>=0; i--) ctx.lineTo(rX + s.jaggedBase[i].x, s.jaggedBase[i].y);
                            ctx.fill();
                        }
                    }
                }
            };

            drawMtn(this.mountains.far, colors.far, true);
            drawMtn(this.mountains.near, colors.near, false);

            // 5. Birds
            for(let b of this.birds) {
                ctx.save();
                ctx.translate(b.x, b.y);
                let s = 4;
                ctx.fillStyle = b.color;
                ctx.fillRect(0,0,s*3,s*2);
                ctx.fillRect(s*3,-s,s*2,s*2);
                ctx.fillStyle = "#ff9800";
                ctx.fillRect(s*5,-s,s,s);
                ctx.fillStyle = b.color;
                ctx.globalAlpha = 0.85;
                if(b.frame===0) ctx.fillRect(s,-s*2,s*2,s*2);
                else ctx.fillRect(s,s,s*2,s*2);
                ctx.restore();
            }

            drawMtn(this.mountains.hills, colors.hills, false);

            // 6. Platforms
            for(let p of this.platforms) {
                ctx.fillStyle = CONSTANTS.COLORS.PLATFORM_BASE;
                ctx.fillRect(p.x, p.y, p.w, p.h);
                ctx.fillStyle = CONSTANTS.COLORS.PLATFORM_TOP;
                ctx.fillRect(p.x, p.y, p.w, 6);
                ctx.strokeStyle = "rgba(0,0,0,0.3)";
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x, p.y, p.w, p.h);
            }

            // 7. Stars
            for(let s of this.stars) {
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.rotation);
                const pulse = Math.sin(this.gameTime * 5) * 2 + 1;
                const outR = s.size + pulse;
                const inR = s.size * 0.4;
                ctx.fillStyle = CONSTANTS.COLORS.STAR;
                ctx.shadowColor = CONSTANTS.COLORS.STAR;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                for(let i=0; i<4; i++) {
                    let a = i * (Math.PI/2);
                    ctx.lineTo(outR * Math.cos(a), outR * Math.sin(a));
                    ctx.lineTo(inR * Math.cos(a + Math.PI/4), inR * Math.sin(a + Math.PI/4));
                }
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            }

            // 8. Player
            const p = this.player;
            ctx.fillStyle = CONSTANTS.COLORS.PLAYER;
            ctx.fillRect(p.x, p.y, p.size, p.size);
            ctx.shadowColor = "#e6ac00";
            ctx.shadowBlur = 10;
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x, p.y, p.size, p.size);
            ctx.shadowBlur = 0;
        }

        drawCelestial(pShifted) {
            const ctx = this.ctx;
            const sunX = MathUtils.lerp(this.width * 0.15, this.width * 0.85, pShifted);
            const t = 1 - Math.abs(2 * pShifted - 1);
            const sunY = MathUtils.lerp(this.height * 0.25, this.height * 0.15, t);
            const isNight = pShifted > 0.5;
            
            let primary = isNight ? "#ccccee" : "#fff";
            let glowBase = isNight ? "rgba(180, 200, 255, 0.4)" : "rgba(255, 255, 255, 0.4)";
            let fade = 1.0;
            if (pShifted < 0.2 || pShifted > 0.8) {
                fade = MathUtils.clamp((1 - Math.abs(2 * pShifted - 1)) * 2, 0.1, 1.0);
            }

            ctx.save();
            let glow = ctx.createRadialGradient(sunX, sunY, 20, sunX, sunY, 160);
            glow.addColorStop(0, glowBase.replace('0.4', String(0.4 * fade)));
            glow.addColorStop(1, glowBase.replace('0.4', '0'));
            ctx.fillStyle = glow;
            ctx.beginPath(); ctx.arc(sunX, sunY, 160, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = primary;
            ctx.globalAlpha = fade;
            ctx.beginPath(); ctx.arc(sunX, sunY, 30, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        loop(now) {
            const dt = Math.min(0.033, (now - this.lastTime) / 1000);
            this.lastTime = now;
            this.gameTime += dt;
            this.update(dt);
            this.draw();
            requestAnimationFrame(this.loop);
        }
    }

    new Game();
})();
</script>
</body>
</html>
