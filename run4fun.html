<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>run4fun</title>

<style>
  :root {
    --bg-color: #4b8ce6;
    --font-main: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    --font-display: "Georgia", serif;
    --font-mono: monospace;
    --font-impact: "Impact", sans-serif;

    /* Rarity Colors */
    --r-common: #b0b0b0;    
    --r-uncommon: #2ecc71;  
    --r-rare: #00d4ff;      
    --r-epic: #bd00ff;      
    --r-legendary: #f39c12; 
    --r-mythic: #f1c40f;    
  }

  html, body {
    margin: 0; height: 100%; background: var(--bg-color);
    overflow: hidden; font-family: var(--font-main);
    touch-action: none; user-select: none; -webkit-user-select: none;
  }

  #game { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }

  /* --- UI OVERLAYS --- */
  .ui-layer {
    position: absolute; pointer-events: none; color: white;
    font-weight: bold; text-shadow: 2px 2px 0 #000; z-index: 10;
  }

  /* HUD CONTAINER */
  #hud-container {
    position: absolute; top: 20px; left: 20px;
    display: flex; align-items: center; gap: 20px;
    z-index: 10; pointer-events: none;
  }

  #hud-stats {
    display: flex; flex-direction: column; gap: 8px;
    font-family: var(--font-impact); letter-spacing: 1px;
  }

  .hud-box {
    background: linear-gradient(90deg, rgba(0,0,0,0.8), rgba(0,0,0,0.4));
    border-left: 4px solid #fff;
    padding: 8px 15px;
    border-radius: 0 4px 4px 0;
    font-size: 20px;
    color: white;
    display: flex; align-items: center; gap: 10px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    text-shadow: 1px 1px 0 #000;
    min-width: 140px;
  }
  
  #hud-stars { border-left-color: #ffd700; color: #ffd700; }
  .hud-icon { width: 20px; text-align: center; }

  #clock-canvas {
    width: 80px; height: 80px;
    image-rendering: pixelated;
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5));
    border-radius: 50%;
  }

  #overlay-center {
    left: 50%; top: 50%; transform: translate(-50%, -50%);
    font-size: 30px; text-align: center; width: 100%;
    transition: opacity 0.3s ease;
  }

  /* --- MULTIPLIER --- */
  #multiplier-container {
    position: absolute; top: 100px; left: 50%;
    transform: translateX(-50%) scale(0.8);
    font-family: var(--font-impact); text-transform: uppercase;
    color: #ffd700; opacity: 0; pointer-events: none; z-index: 12;
    transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    display: flex; flex-direction: column; align-items: center;
  }
  #multiplier-container.active { opacity: 1; transform: translateX(-50%) scale(1); }
  
  #multiplier-text {
    font-size: 50px; font-weight: 900; -webkit-text-stroke: 2px black;
    animation: rainbow 0.5s linear infinite;
  }
  #multiplier-timer { display: none; }

  @keyframes rainbow {
    0% { text-shadow: 0 0 15px #ff0000; } 20% { text-shadow: 0 0 15px #ffff00; }
    40% { text-shadow: 0 0 15px #00ff00; } 60% { text-shadow: 0 0 15px #00ffff; }
    80% { text-shadow: 0 0 15px #0000ff; } 100% { text-shadow: 0 0 15px #ff00ff; }
  }

  /* --- SHOP BUTTON --- */
  #shop-btn-wrap {
    position: absolute; top: 20px; right: 20px; z-index: 50;
    cursor: pointer; filter: drop-shadow(0 0 15px rgba(0,0,0,0.5));
    transition: transform 0.1s;
    display: none; 
  }
  #shop-btn-wrap:active { transform: scale(0.95); }
  
  #shop-btn {
    position: relative; background: #000; color: #fff; border: none;
    font-family: var(--font-impact); font-size: 36px; padding: 15px 35px;
    text-transform: uppercase; letter-spacing: 2px; overflow: hidden;
    display: flex; align-items: center; gap: 15px; transform: skewX(-5deg);
  }
  #shop-btn::before {
    content: ''; position: absolute; top: 50%; left: 50%;
    width: 350px; height: 350px; border-radius: 50%;
    background: conic-gradient(#ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080, #ff0000);
    animation: spin 2.5s linear infinite; z-index: 0;
    transform: translate(-50%, -50%);
  }
  #shop-btn::after { content: ''; position: absolute; inset: 6px; background: #000; z-index: 0; }
  #shop-btn > * { position: relative; z-index: 1; transform: skewX(5deg); text-shadow: 0 0 10px rgba(255,255,255,0.5); }
  
  .star-icon { color: #ffff00; animation: pulse 0.5s infinite alternate; }
  @keyframes spin { from { transform: translate(-50%,-50%) rotate(0deg); } to { transform: translate(-50%,-50%) rotate(360deg); } }
  @keyframes pulse { from { transform: skewX(5deg) scale(1); } to { transform: skewX(5deg) scale(1.3); } }

  /* --- SHOP MODAL --- */
  #shop-modal {
    position: absolute; inset: 0; background: rgba(5, 5, 10, 0.98);
    z-index: 100; display: none; flex-direction: column; align-items: center;
    padding: 40px 20px;
    overflow-y: auto;
  }
  #shop-title {
    font-family: var(--font-impact); font-size: 50px; color: white;
    text-transform: uppercase; text-shadow: 3px 3px 0 #bd00ff; letter-spacing: 2px; margin-bottom: 10px;
  }
  #shop-currency {
    color: #ffd700; font-size: 20px; font-family: var(--font-mono);
    padding: 8px 25px; border: 1px solid #ffd700; border-radius: 20px;
    background: rgba(0,0,0,0.5); box-shadow: 0 0 10px rgba(255,215,0,0.2); margin-bottom: 40px;
  }
  #shop-grid {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 25px; width: 100%; max-width: 900px; padding: 20px;
  }
  .shop-item {
    background: linear-gradient(135deg, #2a2a3a, #151520); border: 2px solid #333;
    display: flex; flex-direction: column; align-items: center; padding: 15px;
    cursor: pointer; position: relative; transform: skewX(-5deg);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3); border-bottom-width: 5px; transition: all 0.2s ease;
  }
  .shop-item:hover { transform: scale(1.05) skewX(-5deg); border-color: white; z-index: 2; box-shadow: 0 8px 20px rgba(0,0,0,0.5); }
  
  .shop-item[data-r="common"] { border-bottom-color: var(--r-common); }
  .shop-item[data-r="uncommon"] { border-bottom-color: var(--r-uncommon); }
  .shop-item[data-r="rare"] { border-bottom-color: var(--r-rare); }
  .shop-item[data-r="epic"] { border-bottom-color: var(--r-epic); }
  .shop-item[data-r="legendary"] { border-bottom-color: var(--r-legendary); }
  .shop-item[data-r="mythic"] { border-bottom-color: var(--r-mythic); box-shadow: 0 0 20px var(--r-mythic); }
  
  .shop-item.equipped { border-color: #ffd700; box-shadow: 0 0 15px rgba(255,215,0,0.6); }
  .shop-item.equipped::after {
    content: 'EQUIPPED'; position: absolute; top: -10px; background: #ffd700;
    color: black; font-weight: bold; font-size: 10px; padding: 2px 8px; transform: skewX(5deg);
  }
  .item-preview {
    width: 110px; height: 110px; background: rgba(0,0,0,0.3);
    margin-bottom: 15px; display: flex; justify-content: center; align-items: center; 
    border-radius: 4px;
    transform: skewX(5deg);
  }
  .item-preview canvas { width: 90px; height: 90px; image-rendering: pixelated; } 
  
  .item-name { color: white; font-weight: 800; font-size: 16px; margin-bottom: 5px; text-align: center; text-transform: uppercase; transform: skewX(5deg); }
  .shop-item[data-r="mythic"] .item-name { color: var(--r-mythic); }
  .item-price { color: #ffd700; font-size: 14px; font-family: var(--font-mono); font-weight: bold; transform: skewX(5deg); }

  #shop-close {
    margin-top: 40px; background: #b00; color: white; border: none;
    padding: 15px 60px; font-size: 24px; font-family: var(--font-impact);
    cursor: pointer; transform: skewX(-10deg); text-transform: uppercase; letter-spacing: 1px;
    transition: background 0.2s;
  }
  #shop-close:hover { background: #d00; }

  /* --- DEATH SCREEN --- */
  #death-screen {
    position: absolute; inset: 0; display: flex; flex-direction: column;
    justify-content: center; align-items: center; background: black;
    opacity: 0; pointer-events: none; transition: opacity 2s ease-in;
    z-index: 20;
  }
  #death-title {
    font-family: "Times New Roman", serif;
    font-size: 100px; 
    color: #8d0808; /* Dark Red */
    text-transform: uppercase;
    letter-spacing: 15px;
    margin-bottom: 30px; 
    text-align: center;
    text-shadow: 0 0 15px rgba(139, 0, 0, 0.6);
    transform: scale(1.2);
    transition: transform 3s ease-out, opacity 1s;
    opacity: 0;
  }
  #death-screen.active #death-title { transform: scale(1); opacity: 1; }
  #death-sub { 
    font-family: "Times New Roman", serif; font-size: 24px; color: #888; 
    letter-spacing: 2px; text-align: center; margin-top: 20px; text-transform: uppercase;
  }

  /* --- PAUSE SCREEN --- */
  #pause-screen {
    position: absolute; inset: 0; background: rgba(0,0,0,0.8);
    display: none; flex-direction: column; justify-content: center; align-items: center;
    z-index: 90; color: white; font-family: var(--font-impact); cursor: pointer;
    backdrop-filter: blur(5px);
  }
  #pause-screen:hover #pause-sub { color: #fff; text-shadow: 0 0 10px white; }
  #pause-title { font-size: 60px; letter-spacing: 5px; margin-bottom: 20px; }
  #pause-timer { font-size: 100px; color: #ff3333; font-family: var(--font-mono); }
  #pause-sub { font-size: 20px; margin-top: 20px; color: #aaa; font-family: var(--font-main); transition: all 0.2s; }

  /* --- CHEAT MODAL --- */
  #cheat-modal {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95); padding: 25px; border: 2px solid #ffd700;
    color: white; font-family: var(--font-mono); z-index: 200; display: none;
    flex-direction: column; gap: 15px; min-width: 320px;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
  }
  .cheat-row { display: flex; justify-content: space-between; align-items: center; }
  .cheat-input { background: #222; color: #0f0; border: 1px solid #555; padding: 5px; width: 100px; font-family: monospace; }
  .cheat-input::-webkit-outer-spin-button, .cheat-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
  .cheat-input { -moz-appearance: textfield; }
  .cheat-check { width: 20px; height: 20px; }
  #cheat-close { margin-top: 10px; background: #ffd700; color: black; border: none; padding: 10px; font-weight: bold; cursor: pointer; text-transform: uppercase; }
  #cheat-close:hover { background: #fff; }

  /* --- CRACK MODE POPUP --- */
  .win-popup {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 320px; background: #c0c0c0; border: 2px solid;
    border-color: #fff #000 #000 #fff; box-shadow: 4px 4px 10px rgba(0,0,0,0.5);
    font-family: "Segoe UI", sans-serif; font-size: 14px; color: black;
    display: none; flex-direction: column; z-index: 300;
  }
  .win-header {
    background: #000080; color: white; padding: 3px 6px; font-weight: bold;
    display: flex; justify-content: space-between; align-items: center;
  }
  .win-close {
    background: #c0c0c0; border: 1px solid; border-color: #fff #000 #000 #fff;
    width: 16px; height: 14px; line-height: 12px; text-align: center; color: black;
    cursor: pointer; font-size: 10px; font-family: sans-serif;
  }
  .win-close:active { border-color: #000 #fff #fff #000; }
  .win-body { padding: 20px; display: flex; gap: 15px; align-items: center; }
  .win-icon { 
      width: 32px; height: 32px; background: #f00; border-radius: 50%; 
      display:flex; align-items:center; justify-content:center; 
      color:white; font-weight:bold; font-size:24px; border: 2px solid #800000;
  }
  .win-buttons { padding: 10px; display: flex; justify-content: center; gap: 15px; }
  .win-btn {
    border: 1px solid; border-color: #fff #000 #000 #fff; background: #c0c0c0;
    padding: 5px 25px; cursor: pointer; font-family: sans-serif; min-width: 70px;
  }
  .win-btn:active { border-color: #000 #fff #fff #000; padding: 6px 24px 4px 26px; }

  /* --- CRACK MODE LOADING --- */
  #crack-loading {
    position: absolute; inset: 0; background: #000; color: #0f0; font-family: monospace;
    display: none; flex-direction: column; justify-content: center; align-items: center;
    font-size: 24px; z-index: 301;
  }
  .loading-bar { border: 2px solid #0f0; padding: 2px; width: 300px; height: 20px; margin-top: 20px; }
  .loading-fill { height: 100%; background: #0f0; width: 0%; transition: width 2s linear; }

  /* --- CRACK MODE (FPS) HUD --- */
  #fps-overlay {
    display: none; position: absolute; inset: 0; pointer-events: none; z-index: 50;
    box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
  }
  .vignette {
    position: absolute; inset: 0;
    background: radial-gradient(circle, transparent 50%, black 100%);
  }

  #touch-btn {
    position: absolute; right: 20px; bottom: 20px; width: 75px; height: 75px;
    border-radius: 50%; background: #ffd42a; display: flex; align-items: center; justify-content: center;
    font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer; z-index: 15; font-size: 24px;
    user-select: none;
  }
  @media (min-width: 700px) { #touch-btn { display: none; } }
  @media (max-width: 600px) { #death-title { font-size: 50px; letter-spacing: 5px; } }
</style>
</head>

<body>
<canvas id="game"></canvas>

<div id="fps-overlay">
  <div class="vignette"></div>
</div>

<div id="hud-container">
  <div id="hud-stats">
    <div class="hud-box" id="hud-score">
      <span class="hud-icon">üèÜ</span> <span id="score-val">0</span>
    </div>
    <div class="hud-box" id="hud-stars">
      <span class="hud-icon">‚òÖ</span> <span id="stars-val">0</span>
    </div>
  </div>
  <canvas id="clock-canvas" width="64" height="64"></canvas>
</div>

<div id="overlay-center" class="ui-layer">Tap / Space to Start</div>

<div id="multiplier-container">
  <div id="multiplier-text">X2 STARS!</div>
  <div id="multiplier-timer"></div> 
</div>

<div id="shop-btn-wrap">
  <button id="shop-btn">
    <div class="star-icon">‚òÖ</div> <span>ITEM SHOP</span> <div class="star-icon">‚òÖ</div>
  </button>
</div>

<div id="shop-modal">
  <div id="shop-title">Item Shop</div>
  <div id="shop-currency">STARS: 0</div>
  <div id="shop-grid"></div>
  <button id="shop-close">Back To Game</button>
</div>

<div id="death-screen">
  <div id="death-title">YOU DIED</div>
  <div id="death-sub"></div> 
</div>

<div id="pause-screen">
  <div id="pause-title">PAUSED</div>
  <div id="pause-timer">20.00</div>
  <div id="pause-sub">CLICK OR ESC TO UNPAUSE</div>
</div>

<div id="touch-btn">‚ñ≤</div>

<!-- CHEAT MENU -->
<div id="cheat-modal">
  <div style="text-align:center; font-weight:bold; margin-bottom:10px; color:#ffd700; font-size: 20px;">/// DEV CONSOLE ///</div>
  <div class="cheat-row"><span>Score:</span> <input type="number" id="c-score" class="cheat-input"></div>
  <div class="cheat-row"><span>Stars:</span> <input type="number" id="c-stars" class="cheat-input"></div>
  <div class="cheat-row"><span>God Mode:</span> <input type="checkbox" id="c-god" class="cheat-check"></div>
  <div class="cheat-row"><span>Fly Mode:</span> <input type="checkbox" id="c-fly" class="cheat-check"></div>
  <button id="cheat-close">APPLY & CLOSE</button>
</div>

<!-- WIN 95 POPUP -->
<div id="win-popup" class="win-popup">
  <div class="win-header"><span>System Message</span><div class="win-close" id="win-x">X</div></div>
  <div class="win-body">
    <div class="win-icon">!</div>
    <div id="win-msg" style="font-weight:bold;">Enable CRACK MODE?</div>
  </div>
  <div class="win-buttons">
    <button class="win-btn" id="win-yes">Yes</button>
    <button class="win-btn" id="win-no">No</button>
  </div>
</div>

<!-- FAKE LOADING -->
<div id="crack-loading">
  <div>ENTERING NIGHTMARE...</div>
  <div class="loading-bar"><div class="loading-fill" id="load-fill"></div></div>
</div>

<script>
(() => {
  /** CONFIG & DATA */
  const PIXEL_DATA = {
    // ITEMS
    cone: { colors: { 1:"#ff6600", 2:"#ffffff" }, map: ["000010000","000010000","000111000","000111000","001111100","001111100","022222220","111111111"] },
    bandana: { colors: { 1:"#3366cc", 2:"#224488" }, map: ["000000000","111111111","121212121","111111111","100000001","100000001","200000002"] },
    fedora: { colors: { 1:"#5d4037", 2:"#3e2723", 3:"#111" }, map: ["000111100","001111110","001121110","011111111","133333333","111111111"] },
    safety: { colors: { 1:"#ffeb3b", 2:"#fbc02d" }, map: ["000111100","001111110","011111111","111222111","111111111","111111111"] },
    afro: { colors: { 1:"#212121", 2:"#424242" }, map: ["001111100","011211110","111112111","112111111","111111211","111111111","011111110"] },
    astro: { colors: { 1:"#eee", 2:"#81d4fa", 3:"#ddd" }, map: ["001111100","011111110","112222211","112222211","112222211","111111111","011333110"] },
    spartan: { colors: { 1:"#daa520", 2:"#c0392b" }, map: ["000022200","000222220","001111110","001111110","011000110","111000111","111000111","011001100"] },
    devil: { colors: { 1:"#d32f2f", 2:"#b71c1c", 3:"#fff" }, map: ["100000001","110000011","110000011","011000110","000000000"] },
    king: { colors: { 1:"#ffd700", 2:"#e91e63", 3:"#00bcd4" }, map: ["100010001","100010001","110111011","111111111","121313121","111111111"] },
    wizardMega: { colors: { 1:"#673ab7", 2:"#4527a0", 3:"#ffd700" }, map: ["00000000212000","00000000212000","0000002112000","00000021131200","00000021111200","00000211311200","00002111111200","00021311113120","00211111111120","02113333333120","21333333333312","11111111111111","13113111131131","11111111111111"] },
    
    // Multipliers
    "2": { colors: { 1: "#ffffff" }, map: ["111000101","001000101","111000010","100000101","111000101"] },
    "3": { colors: { 1: "#ffffff" }, map: ["111000101","001000101","111000010","001000101","111000101"] },
    "5": { colors: { 1: "#ffffff" }, map: ["111000101","100000101","111000010","001000101","111000101"] }
  };

  const SHOP_ITEMS = [
    { id: 'cone', name: 'Traffic Cone', price: 0, rarity: 'common' },
    { id: 'bandana', name: 'Blue Bandana', price: 25, rarity: 'common' },
    { id: 'fedora', name: 'Detective', price: 50, rarity: 'uncommon' },
    { id: 'safety', name: 'Safety First', price: 100, rarity: 'uncommon' },
    { id: 'afro', name: 'Disco King', price: 150, rarity: 'rare' },
    { id: 'astro', name: 'Space Walker', price: 250, rarity: 'rare' },
    { id: 'spartan', name: 'Spartan Helm', price: 500, rarity: 'epic' },
    { id: 'devil', name: 'Lil\' Horns', price: 666, rarity: 'epic' },
    { id: 'king', name: 'Royal Crown', price: 1000, rarity: 'legendary' },
    { id: 'wizardMega', name: 'Grand Magus', price: 2500, rarity: 'mythic' }
  ];

  const CONSTANTS = {
    PHYSICS: { GRAVITY: 1800, JUMP: -760, SPEED_START: 260, SPEED_MAX: 900, SPEED_INC: 8, SCORE_MULT: 0.15 },
    DIMS: { PLAYER: 36, PLAT_H: 24, STAR: 24, GROUND_OFF: 140, DEATH_Z: 100 },
    GEN: { 
        GAP: {MIN:80, MAX:400}, 
        WIDTH: {MIN:260, MAX:480}, 
        Y_VAR: {MIN:-50, MAX:90},
        STAR_C: 0.4, 
        GAP_STAR_C: 0.1, 
        MULT_C: 0.06, 
        CYCLE: 15000 // 15k Cycle
    },
    COLORS: { PLAT: "#5d4037", PLAT_TOP: "#4caf50", PLAYER: "#ffd42a", STAR: "#ffd700", BIRDS_C: ["#f0f8ff","#808080","#333333"], BIRDS_R: ["#aeea00","#ff0055","#00ccff"] }
  };

  /** UTILITIES */
  const Utils = {
    rand: (a, b) => Math.random() * (b - a) + a,
    randInt: (a, b) => Math.floor(Math.random() * (b - a + 1)) + a,
    clamp: (v, a, b) => Math.max(a, Math.min(b, v)),
    lerp: (a, b, t) => a + (b - a) * t,
    lerpColor: (a, b, amount) => {
      const ah = parseInt(a.slice(1), 16), bh = parseInt(b.slice(1), 16);
      const ar = ah>>16, ag = (ah>>8)&0xff, ab = ah&0xff, br = bh>>16, bg = (bh>>8)&0xff, bb = bh&0xff;
      return '#' + ((1<<24) + ((ar+(br-ar)*amount)<<16) + ((ag+(bg-ag)*amount)<<8) + (ab+(bb-ab)*amount|0)).toString(16).slice(1);
    },
    AABB: (r1, r2) => r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y
  };

  const StorageManager = {
    KEY: 'run4fun_save_v10',
    load: () => {
      try { 
          let data = JSON.parse(localStorage.getItem(StorageManager.KEY));
          if(!data || !data.unlocked) return { totalStars: 0, unlocked: ['cone'], equipped: null };
          return data;
      }
      catch { return { totalStars: 0, unlocked: ['cone'], equipped: null }; }
    },
    save: (data) => localStorage.setItem(StorageManager.KEY, JSON.stringify(data))
  };

  const AssetFactory = {
    cache: {},
    init() {
      Object.keys(PIXEL_DATA).forEach(key => {
        this.cache[key] = this.createCanvas(PIXEL_DATA[key]);
      });
    },
    createCanvas(art) {
      const rows = art.map.length, cols = art.map[0].length;
      const cvs = document.createElement('canvas');
      cvs.width = cols; cvs.height = rows;
      const ctx = cvs.getContext('2d');
      for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
          if(art.map[r][c] !== '0') {
            ctx.fillStyle = art.colors[art.map[r][c]];
            ctx.fillRect(c, r, 1, 1);
          }
        }
      }
      return { img: cvs, w: cols, h: rows };
    },
    get(id) { return this.cache[id]; }
  };

  /** FPS MODE ENGINE (RAYCASTER) */
  class RaycasterEngine {
      constructor(cvs) {
          this.cvs = cvs;
          this.ctx = cvs.getContext('2d');
          this.mapW = 24;
          this.mapH = 24;
          this.map = [];
          this.texSize = 64;
          this.player = { x: 12, y: 12, dir: 0, pitch: 0, plane: {x:0, y:0.84} }; // FOV ~80deg
          this.flashlightOn = true;
          
          this.inventory = [
              {id: 'gun', name: 'Glock-19'}, 
              {id: 'knife', name: 'Kitchen Knife'}, 
              {id: 'flashlight', name: 'Hvy Flashlight'}
          ];
          this.activeSlot = 0;

          // Maze
          for(let y=0; y<this.mapH; y++) {
              let row = [];
              for(let x=0; x<this.mapW; x++) {
                  row.push((x===0||x===this.mapW-1||y===0||y===this.mapH-1||Math.random()<0.15) ? 1 : 0);
              }
              this.map.push(row);
          }
          this.map[12][12] = 0; 
          
          this.keys = {w:false, a:false, s:false, d:false};
          window.addEventListener('keydown', e => this.key(e, true));
          window.addEventListener('keyup', e => this.key(e, false));
          
          document.addEventListener("mousemove", (e) => {
              if(document.pointerLockElement === this.cvs) {
                  this.player.dir -= e.movementX * 0.002; // Reversed X
                  this.player.pitch -= e.movementY * 2;
                  this.player.pitch = Math.max(-300, Math.min(300, this.player.pitch)); // Clamp Look
              }
          });
      }

      key(e, state) {
          const k = e.code;
          if(k==='KeyW') this.keys.w = state;
          if(k==='KeyS') this.keys.s = state;
          if(k==='KeyA') this.keys.a = state;
          if(k==='KeyD') this.keys.d = state;
          
          if(state && k==='KeyF') this.flashlightOn = !this.flashlightOn;
          if(state && k.startsWith('Digit')) {
              const n = parseInt(k.replace('Digit','')) - 1;
              if(n >= 0 && n < 9) this.activeSlot = Math.min(n, this.inventory.length-1);
          }
      }

      update(dt) {
          const moveSpeed = 5.0 * dt;
          
          const dx = Math.cos(this.player.dir) * moveSpeed;
          const dy = Math.sin(this.player.dir) * moveSpeed;
          const sx = Math.cos(this.player.dir + Math.PI/2) * moveSpeed;
          const sy = Math.sin(this.player.dir + Math.PI/2) * moveSpeed;
          
          let nx = this.player.x, ny = this.player.y;
          
          if(this.keys.w) { nx += dx; ny += dy; }
          if(this.keys.s) { nx -= dx; ny -= dy; }
          if(this.keys.a) { nx -= sx; ny -= sy; } // Swap A/D
          if(this.keys.d) { nx += sx; ny += sy; } 
          
          if(this.map[Math.floor(ny)][Math.floor(this.player.x)] === 0) this.player.y = ny;
          if(this.map[Math.floor(this.player.y)][Math.floor(nx)] === 0) this.player.x = nx;
      }

      draw(w, h) {
          this.ctx.fillStyle = '#050505';
          this.ctx.fillRect(0, 0, w, h);
          
          const horizon = h/2 + this.player.pitch;

          // Ceiling/Floor
          const grad = this.ctx.createLinearGradient(0,0,0,h);
          grad.addColorStop(0, '#000'); 
          grad.addColorStop(0.5, '#1a1a1a'); 
          grad.addColorStop(1, '#000');
          this.ctx.fillStyle = grad;
          this.ctx.fillRect(0, horizon, w, h - horizon);

          // Raycast
          for(let x = 0; x < w; x += 4) { 
              const cameraX = 2 * x / w - 1;
              const rayDirX = Math.cos(this.player.dir) + this.player.plane.x * Math.cos(this.player.dir - Math.PI/2) * cameraX;
              const rayDirY = Math.sin(this.player.dir) + this.player.plane.y * Math.sin(this.player.dir - Math.PI/2) * cameraX;
              
              let mapX = Math.floor(this.player.x);
              let mapY = Math.floor(this.player.y);
              let sideDistX, sideDistY;
              
              const deltaDistX = Math.abs(1/rayDirX);
              const deltaDistY = Math.abs(1/rayDirY);
              
              let stepX, stepY;
              let hit = 0;
              let side;
              
              if(rayDirX < 0) { stepX = -1; sideDistX = (this.player.x - mapX) * deltaDistX; }
              else { stepX = 1; sideDistX = (mapX + 1.0 - this.player.x) * deltaDistX; }
              if(rayDirY < 0) { stepY = -1; sideDistY = (this.player.y - mapY) * deltaDistY; }
              else { stepY = 1; sideDistY = (mapY + 1.0 - this.player.y) * deltaDistY; }
              
              while(hit === 0) {
                  if(sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                  else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                  if(this.map[mapY][mapX] > 0) hit = 1;
              }
              
              let perpWallDist;
              if(side === 0) perpWallDist = (mapX - this.player.x + (1 - stepX) / 2) / rayDirX;
              else perpWallDist = (mapY - this.player.y + (1 - stepY) / 2) / rayDirY;
              
              const lineHeight = Math.floor(h / perpWallDist);
              const drawStart = -lineHeight / 2 + h / 2 + this.player.pitch;
              
              // Lighting
              let baseColor = side === 1 ? 100 : 140;
              let lightIntensity = 0;
              
              if(this.flashlightOn) {
                  // Calculate radial distance from center screen
                  const centerX = w/2;
                  const centerY = h/2; 
                  // We approximate hit point y as center for simplicity in 2.5D
                  const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2));
                  
                  // Light Circle
                  if(distFromCenter < 250) {
                      lightIntensity = Math.max(0, 255 - perpWallDist * 30);
                      // Soft edge
                      lightIntensity *= (1 - distFromCenter/250);
                  } else {
                      lightIntensity = Math.max(0, 20 - perpWallDist * 5);
                  }
              } else {
                  lightIntensity = Math.max(0, 40 - perpWallDist * 10);
              }
              
              const r = Math.min(255, baseColor * (lightIntensity/255));
              const g = Math.min(255, baseColor * (lightIntensity/255));
              const b = Math.min(255, baseColor * (lightIntensity/255));

              this.ctx.fillStyle = `rgb(${r},${g},${b})`;
              this.ctx.fillRect(x, drawStart, 4, lineHeight);
          }
          
          this.drawUI(w, h);
      }

      drawUI(w, h) {
          const ctx = this.ctx;
          const item = this.inventory[this.activeSlot];
          
          // Hands (Dual - Cry of Fear style often shows two hands for items or interaction)
          // Left Hand (Support)
          ctx.fillStyle = "#111"; // Dark Sleeve
          ctx.fillRect(20, h-150, 100, 150);
          ctx.fillStyle = "#cbb"; // Skin
          ctx.fillRect(40, h-180, 60, 40); 

          // Right Hand (Active)
          ctx.save();
          ctx.translate(w - 200, h - 180);
          
          // Sleeve
          ctx.fillStyle = "#111";
          ctx.fillRect(50, 80, 100, 200);
          
          // Hand/Item Logic (Simulated Low Poly via Gradients)
          if(item) {
              if(item.id === 'gun') {
                  // Glock Slide
                  const slide = ctx.createLinearGradient(0,0,100,0);
                  slide.addColorStop(0, "#444"); slide.addColorStop(0.5, "#777"); slide.addColorStop(1, "#333");
                  ctx.fillStyle = slide;
                  ctx.fillRect(40, 40, 120, 40); // Slide
                  ctx.fillStyle = "#111";
                  ctx.fillRect(50, 80, 30, 60); // Grip
                  // Sights
                  ctx.fillStyle = "#0f0"; ctx.fillRect(155, 38, 3, 3);
              } else if (item.id === 'knife') {
                  ctx.rotate(-0.3);
                  // Handle
                  ctx.fillStyle = "#3e2723";
                  ctx.fillRect(60, 60, 30, 80);
                  // Blade
                  const blade = ctx.createLinearGradient(60,0,100,100);
                  blade.addColorStop(0, "#fff"); blade.addColorStop(1, "#999");
                  ctx.fillStyle = blade;
                  ctx.beginPath();
                  ctx.moveTo(70, 60); ctx.lineTo(90, -60); ctx.lineTo(100, 60);
                  ctx.fill();
                  // Blood stain
                  ctx.fillStyle = "rgba(150,0,0,0.6)";
                  ctx.beginPath(); ctx.arc(85, -20, 10, 0, Math.PI*2); ctx.fill();
              } else if (item.id === 'flashlight') {
                  // Maglite Body
                  const body = ctx.createLinearGradient(0,0,100,0);
                  body.addColorStop(0, "#111"); body.addColorStop(0.5, "#333"); body.addColorStop(1, "#000");
                  ctx.fillStyle = body;
                  ctx.fillRect(50, 50, 120, 40);
                  // Head
                  ctx.fillStyle = "#222";
                  ctx.fillRect(170, 40, 30, 60);
                  // Beam source
                  if(this.flashlightOn) {
                      ctx.fillStyle = "#fff";
                      ctx.fillRect(200, 45, 5, 50);
                  }
              }
          }
          
          // Hand holding it
          ctx.fillStyle = "#cbb"; // Skin
          ctx.beginPath(); ctx.arc(80, 100, 40, 0, Math.PI*2); ctx.fill(); // Knuckles
          
          ctx.restore();

          // Inventory Bar (Minecraft Style)
          const slotSize = 50;
          const startX = w/2 - (9 * slotSize)/2;
          
          // Background
          ctx.fillStyle = "rgba(20,20,20,0.8)";
          ctx.fillRect(startX - 5, h - 60, (slotSize+4)*9 + 6, 55);
          
          for(let i=0; i<9; i++) {
              const x = startX + i*(slotSize+4);
              const isSel = (i === this.activeSlot);
              
              ctx.fillStyle = isSel ? "rgba(200,200,200,0.3)" : "rgba(50,50,50,0.5)";
              ctx.fillRect(x, h - 55, slotSize, slotSize);
              ctx.strokeStyle = isSel ? "#fff" : "#444";
              ctx.lineWidth = isSel ? 3 : 1;
              ctx.strokeRect(x, h - 55, slotSize, slotSize);
              
              if(this.inventory[i]) {
                  ctx.fillStyle = "#ddd";
                  ctx.font = "10px monospace";
                  ctx.fillText(this.inventory[i].name.substring(0,6), x+2, h-40);
              }
          }
          
          // Offhand Slot
          ctx.fillStyle = "rgba(20,20,20,0.8)";
          ctx.fillRect(startX - 70, h - 60, slotSize, slotSize);
          ctx.strokeStyle = "#444"; ctx.lineWidth = 1;
          ctx.strokeRect(startX - 70, h - 60, slotSize, slotSize);
          ctx.fillStyle = "#aaa"; ctx.fillText("OFF", startX - 65, h-35);
      }
  }

  /** GAME CLASSES */
  class Player {
    constructor(groundY) {
      this.size = CONSTANTS.DIMS.PLAYER;
      this.x = 150;
      this.y = groundY - this.size;
      this.vy = 0;
      this.jumps = 2;
      this.alive = true;
    }
    update(dt, platforms, gravity) {
      if (!this.alive) return;
      this.vy += gravity * dt;
      this.y += this.vy * dt;
      const b = this.y + this.size, r = this.x + this.size;
      
      for (const p of platforms) {
        if (r > p.x && this.x < p.x + p.w) {
          const prevY = b - (this.vy * dt);
          if (prevY <= p.y + 5 && b >= p.y && this.vy >= 0) {
            this.y = p.y - this.size;
            this.vy = 0;
            this.jumps = 2;
          }
        }
      }
    }
    jump() {
      if (this.jumps > 0) { this.vy = CONSTANTS.PHYSICS.JUMP; this.jumps--; }
    }
  }

  class DayNightCycle {
    constructor() {
      this.sky = [
        {p:0.0, t:"#004e92", b:"#4ca1af"},
        {p:0.35, t:"#004e92", b:"#4ca1af"},
        {p:0.45, t:"#ff6b00", b:"#ffb457"},
        {p:0.55, t:"#000033", b:"#1e3a8a"},
        {p:0.85, t:"#000033", b:"#1e3a8a"},
        {p:0.95, t:"#ffcc80", b:"#ff9068"},
        {p:1.0, t:"#004e92", b:"#4ca1af"}
      ];
      this.mtn = [
        {p:0.0, f:"#2c3e50", n:"#34495e", h:"#455a64"},
        {p:0.45, f:"#5a3a2a", n:"#6d4e3e", h:"#806653"},
        {p:0.55, f:"#1a1a2e", n:"#282a4a", h:"#3e4064"},
        {p:0.85, f:"#1a1a2e", n:"#282a4a", h:"#3e4064"},
        {p:0.95, f:"#5a3a2a", n:"#6d4e3e", h:"#806653"},
        {p:1.0, f:"#2c3e50", n:"#34495e", h:"#455a64"}
      ];
    }
    get(score) {
      const p = (score % CONSTANTS.GEN.CYCLE) / CONSTANTS.GEN.CYCLE;
      const solve = (arr) => {
        let i = 0; while(i<arr.length-1 && p > arr[i+1].p) i++;
        const t = (p - arr[i].p) / (arr[Math.min(arr.length-1, i+1)].p - arr[i].p);
        return { s: arr[i], e: arr[Math.min(arr.length-1, i+1)], t };
      };
      const s = solve(this.sky), m = solve(this.mtn);
      return {
        skyTop: Utils.lerpColor(s.s.t, s.e.t, s.t), skyBot: Utils.lerpColor(s.s.b, s.e.b, s.t),
        far: Utils.lerpColor(m.s.f, m.e.f, m.t), near: Utils.lerpColor(m.s.n, m.e.n, m.t), hills: Utils.lerpColor(m.s.h, m.e.h, m.t),
        p
      };
    }
  }

  class Game {
    constructor() {
      this.cvs = document.getElementById("game");
      this.ctx = this.cvs.getContext("2d", { alpha: false });
      this.ui = {
        score: document.getElementById("score-val"), stars: document.getElementById("stars-val"),
        clock: document.getElementById("clock-canvas"),
        overlay: document.getElementById("overlay-center"), death: document.getElementById("death-screen"), deathSub: document.getElementById("death-sub"),
        shop: document.getElementById("shop-modal"), shopGrid: document.getElementById("shop-grid"), shopStars: document.getElementById("shop-currency"),
        mult: document.getElementById("multiplier-container"), multTxt: document.getElementById("multiplier-text"), multTime: document.getElementById("multiplier-timer"),
        shopBtn: document.getElementById("shop-btn-wrap"), closeShop: document.getElementById("shop-close"), touch: document.getElementById("touch-btn"),
        pause: document.getElementById("pause-screen"), pauseTimer: document.getElementById("pause-timer"),
        cheat: document.getElementById("cheat-modal"), winPopup: document.getElementById("win-popup"),
        winMsg: document.getElementById("win-msg"), crackLoad: document.getElementById("crack-loading"), loadFill: document.getElementById("load-fill"),
        fpsHud: document.getElementById("fps-overlay")
      };
      this.clockCtx = this.ui.clock.getContext("2d");
      
      this.cheats = { god: false, fly: false };
      this.crackMode = false;
      this.crackDenials = 0;
      this.dialogOpen = false;
      this.cutsceneTime = 0;
      this.inCutscene = false;

      this.cycle = new DayNightCycle();
      this.data = StorageManager.load();
      AssetFactory.init();

      this.loop = this.loop.bind(this);
      window.addEventListener("resize", () => this.resize());
      
      const input = (e) => {
        if (e.code === "Escape") { this.togglePause(); return; }
        if (e.code === "KeyC") { this.toggleCheat(); return; }
        
        if(this.crackMode && this.fpsEngine) {
            return; 
        }

        if(this.shopOpen || this.isPaused || this.dialogOpen || this.inCutscene) return;
        if(e.type === 'keydown' && (e.code!=="Space" && e.code!=="KeyW")) return;
        if(e.preventDefault) e.preventDefault(); 
        this.handleInput();
      };
      window.addEventListener("keydown", input);
      window.addEventListener("pointerdown", (e) => {
        if(this.crackMode) {
            this.cvs.requestPointerLock();
            return;
        }
        if(e.target.closest('#shop-modal') || e.target.closest('#shop-btn-wrap') || e.target.closest('#cheat-modal') || e.target.closest('.win-popup')) return;
        input(e);
      });

      this.ui.shopBtn.addEventListener("click", () => this.toggleShop(true));
      this.ui.closeShop.addEventListener("click", () => this.toggleShop(false));
      this.ui.pause.addEventListener("click", () => this.togglePause());

      document.getElementById("cheat-close").onclick = () => this.applyCheats();
      
      document.getElementById("win-yes").onclick = () => this.enableCrackMode();
      const closeFunc = () => this.denyCrackMode();
      document.getElementById("win-no").onclick = closeFunc;
      document.getElementById("win-x").onclick = closeFunc;

      this.resize();
      this.reset();
      this.updateShop();
      requestAnimationFrame(this.loop);
    }

    handleInput() {
      if (!this.player.alive) { this.reset(); return; }
      if (this.startDelay) {
        this.startDelay = false;
        this.ui.overlay.style.opacity = 0;
        this.ui.shopBtn.style.display = "none";
        this.player.jumps = 2;
        return;
      }
      if (this.cheats.fly) {
          this.player.vy = CONSTANTS.PHYSICS.JUMP; 
      } else {
          this.player.jump();
      }
    }

    toggleCheat() {
        if(this.dialogOpen) return;
        const s = this.ui.cheat.style.display === "flex";
        this.ui.cheat.style.display = s ? "none" : "flex";
        this.dialogOpen = !s;
        
        if(!s) { 
            document.getElementById("c-score").value = Math.floor(this.score);
            document.getElementById("c-stars").value = this.data.totalStars;
            document.getElementById("c-god").checked = this.cheats.god;
            document.getElementById("c-fly").checked = this.cheats.fly;
        }
    }

    applyCheats() {
        this.score = parseInt(document.getElementById("c-score").value) || this.score;
        this.data.totalStars = parseInt(document.getElementById("c-stars").value) || this.data.totalStars;
        this.cheats.god = document.getElementById("c-god").checked;
        this.cheats.fly = document.getElementById("c-fly").checked;
        
        StorageManager.save(this.data);
        this.ui.stars.innerText = this.data.totalStars + this.runStars;
        this.ui.cheat.style.display = "none";
        this.dialogOpen = false;
    }

    togglePause() {
        if (!this.player.alive || this.startDelay || this.shopOpen || this.dialogOpen || this.inCutscene) return;
        this.isPaused = !this.isPaused;
        this.ui.pause.style.display = this.isPaused ? "flex" : "none";
    }

    die() {
        if (this.cheats.god) return; 

        if (this.data.equipped === 'wizardMega' && !this.revived) {
            this.revived = true;
            this.player.vy = -1200; 
            this.player.y = this.h - 200; 
            for(let i=0; i<30; i++) {
                this.objs.parts.push({
                    x: this.player.x + 18, y: this.player.y + 18,
                    vx: Math.cos(i/30 * Math.PI*2) * 500, vy: Math.sin(i/30 * Math.PI*2) * 500,
                    l: 1.0, c: "#a020f0"
                });
            }
            return;
        }

        this.player.alive = false;
        this.data.totalStars += this.runStars;
        StorageManager.save(this.data);
        this.ui.death.style.opacity = 1;
        this.ui.death.className = "active"; 
        this.ui.death.style.pointerEvents = "auto";
        this.ui.deathSub.innerText = "Press Space to Restart";
        this.isPaused = false;
        this.ui.pause.style.display = "none";
        
        setTimeout(() => {
            if(!this.player.alive) this.ui.shopBtn.style.display = "block";
        }, 3000); 

        this.ui.mult.className = "";
        this.ui.multTime.innerText = "";
    }

    toggleShop(open) {
      if(this.isPaused || this.dialogOpen) return;
      this.shopOpen = open;
      this.ui.shop.style.display = open ? 'flex' : 'none';
      this.ui.shopBtn.style.display = open ? 'none' : 'block';
      this.ui.mult.style.display = open ? 'none' : 'flex';
      if(open) this.updateShop();
    }

    updateShop() {
      this.ui.shopStars.innerText = "STARS: " + this.data.totalStars;
      this.ui.shopGrid.innerHTML = '';
      SHOP_ITEMS.forEach(item => {
        const owned = this.data.unlocked.includes(item.id);
        const equipped = this.data.equipped === item.id;
        const el = document.createElement('div');
        el.className = `shop-item ${equipped ? 'equipped' : ''}`;
        el.dataset.r = item.rarity;
        
        const c = document.createElement('canvas'); 
        const art = AssetFactory.get(item.id);
        const scale = art.h > 10 ? 5 : 7;
        c.width=90; c.height=90; 
        
        const ctx = c.getContext('2d'); 
        ctx.imageSmoothingEnabled = false;
        
        const drawW = art.w * scale;
        const drawH = art.h * scale;
        ctx.drawImage(art.img, (90-drawW)/2, (90-drawH)/2, drawW, drawH);

        el.innerHTML = `<div class="item-preview"></div><div class="item-name">${item.name}</div><div class="item-price">${owned ? (equipped?'EQUIPPED':'OWNED') : item.price+' Stars'}</div>`;
        el.firstChild.appendChild(c);
        
        el.onclick = () => {
           if(owned) {
             this.data.equipped = (this.data.equipped === item.id) ? null : item.id;
             StorageManager.save(this.data);
           } else if(this.data.totalStars >= item.price) {
             this.data.totalStars -= item.price;
             this.data.unlocked.push(item.id);
             this.data.equipped = item.id;
             StorageManager.save(this.data);
           } else {
             const p = el.querySelector('.item-price');
             const old = p.innerText; p.innerText = "NEED MORE STARS!"; p.style.color="#f00";
             setTimeout(()=>{ p.innerText=old; p.style.color="#ffd700"; }, 1000);
           }
           this.updateShop();
        };
        this.ui.shopGrid.appendChild(el);
      });
    }

    /* --- CRACK MODE LOGIC --- */
    checkCrackTrigger(prevP, currP) {
        if (prevP > 0.9 && currP < 0.1 && !this.crackMode) {
            this.startCrackSequence();
        }
    }

    startCrackSequence() {
        this.dialogOpen = true; 
        this.crackDenials = 0;
        this.ui.winPopup.style.display = "flex";
    }

    denyCrackMode() {
        this.crackDenials++;
        if (this.crackDenials >= 3) {
            this.ui.winPopup.style.display = "none";
            this.dialogOpen = false; 
        } else {
            this.ui.winPopup.style.display = "none";
            setTimeout(() => {
                this.ui.winPopup.style.left = (50 + Utils.rand(-10,10)) + "%";
                this.ui.winPopup.style.top = (50 + Utils.rand(-10,10)) + "%";
                this.ui.winPopup.style.display = "flex";
            }, 100);
        }
    }

    enableCrackMode() {
        this.ui.winPopup.style.display = "none";
        this.ui.crackLoad.style.display = "flex";
        this.ui.loadFill.style.width = "0%";
        setTimeout(() => { this.ui.loadFill.style.width = "40%"; }, 500);
        setTimeout(() => { this.ui.loadFill.style.width = "80%"; }, 1200);
        setTimeout(() => { 
            this.ui.loadFill.style.width = "100%";
            setTimeout(() => {
                this.ui.crackLoad.style.display = "none";
                this.startCutscene();
            }, 500);
        }, 2000);
    }

    startCutscene() {
        this.inCutscene = true;
        this.cutsceneTime = 0;
        this.dialogOpen = false;
    }

    activateFPSMode() {
        this.inCutscene = false;
        this.crackMode = true;
        // Hide 2D UI
        document.getElementById("hud-container").style.display = "none";
        document.getElementById("overlay-center").style.display = "none";
        this.ui.fpsHud.style.display = "block";
        
        // Init FPS Engine
        this.fpsEngine = new RaycasterEngine(this.cvs);
    }

    resize() {
      this.dpr = window.devicePixelRatio || 1;
      this.cvs.width = window.innerWidth * this.dpr;
      this.cvs.height = window.innerHeight * this.dpr;
      this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
      this.ctx.imageSmoothingEnabled = false;
      this.w = this.cvs.width / this.dpr;
      this.h = this.cvs.height / this.dpr;
      if(this.player) this.player.y = Math.min(this.player.y, this.groundY - 50);
    }

    get groundY() { return this.h - CONSTANTS.DIMS.GROUND_OFF; }

    reset() {
      this.player = new Player(this.groundY);
      this.speed = CONSTANTS.PHYSICS.SPEED_START;
      this.score = 0;
      this.runStars = 0;
      this.startDelay = true;
      this.time = 0;
      this.pauseTime = 20.0;
      this.isPaused = false;
      this.revived = false; 
      this.lastT = performance.now();
      
      this.objs = { plats: [], stars: [], mults: [], parts: [], birds: [], clouds: [], mtn: { f:[], n:[], h:[] } };
      this.activeMult = { val: 1, time: 0 };
      this.bgStars = []; 
      for(let i=0; i<35; i++) this.bgStars.push({x:Math.random(), y:Math.random(), s:Math.random()*2+1, a:Math.random()});
      this.shootStar = null;

      this.ui.score.innerText = "0";
      this.ui.stars.innerText = this.data.totalStars;
      this.ui.overlay.style.opacity = 1;
      this.ui.death.style.opacity = 0;
      this.ui.death.className = "";
      this.ui.death.style.pointerEvents = "none";
      this.ui.shopBtn.style.display = "block";
      this.ui.mult.className = "";
      this.ui.multTime.innerText = "";
      this.ui.pause.style.display = "none";

      this.initWorld();
    }

    initWorld() {
      const H = this.h;
      const layer = (arr, w, min, max, s, type) => {
        let x = 0, y = Utils.rand(min, max);
        while(x < this.w + w) {
          let segs = (type === 'far') ? 8 : 4;
          let segW = w / segs;
          let pts = [{x:0,y}];
          let cy = y;
          for(let i=1; i<=segs; i++) {
            cy = Utils.clamp(cy + Utils.rand(type==='hills'?-50:-100, type==='hills'?50:100), min, max);
            if(type === 'near') cy = Utils.clamp(cy + Utils.rand(-40,40), min, max); 
            pts.push({x:i*segW, y:cy});
          }
          let snowNoise = [];
          if(type === 'far') {
              const noiseSteps = Math.ceil(w / 10);
              for(let k=0; k<=noiseSteps; k++) snowNoise.push(Utils.rand(-5, 5));
          }
          arr.push({x, w, pts, s, snowNoise});
          x += w; y = cy;
        }
      };
      layer(this.objs.mtn.f, 800, H-650, H-400, 0.15, 'far');
      layer(this.objs.mtn.n, 700, H-450, H-250, 0.3, 'near');
      layer(this.objs.mtn.h, 450, H-180, H-100, 0.6, 'hills');
      
      for(let i=0; i<6; i++) {
          let cx = Utils.rand(0, this.w);
          let parts = [];
          parts.push({x:0, y:0, w:80, h:40});
          parts.push({x:-20, y:10, w:40, h:30});
          parts.push({x:60, y:10, w:40, h:30});
          parts.push({x:10, y:-15, w:50, h:30});
          this.objs.clouds.push({x:cx, y:Utils.rand(20,H*0.4), parts, s:Utils.rand(10,25), a:Utils.rand(0.6,0.9)});
      }
      for(let i=0; i<3; i++) this.spawnBird();
      
      let cx = this.player.x - 60;
      this.objs.plats.push({x:cx, y:this.groundY, w:500, h:CONSTANTS.DIMS.PLAT_H});
      cx += 560;
      for(let i=0; i<6; i++) cx = this.addPlatform(cx, i);
    }

    checkOverlap(x, y, margin=40) {
        for(let s of this.objs.stars) {
            if(Math.abs(s.x - x) < margin && Math.abs(s.y - y) < margin) return true;
        }
        for(let m of this.objs.mults) {
            if(Math.abs(m.x - x) < margin && Math.abs(m.y - y) < margin) return true;
        }
        return false;
    }

    addPlatform(sx, idx) {
      const gap = Utils.rand(CONSTANTS.GEN.GAP.MIN, CONSTANTS.GEN.GAP.MAX);
      const w = Utils.rand(CONSTANTS.GEN.WIDTH.MIN, CONSTANTS.GEN.WIDTH.MAX);
      const ly = this.objs.plats.length ? this.objs.plats[this.objs.plats.length-1].y : this.groundY;
      const y = Utils.clamp(ly + Utils.rand(CONSTANTS.GEN.Y_VAR.MIN, CONSTANTS.GEN.Y_VAR.MAX), 70, this.h - 80);
      const p = { x: sx + gap, y, w, h: CONSTANTS.DIMS.PLAT_H };
      this.objs.plats.push(p);

      const tryMult = (this.activeMult.time <= 0) && (Math.random() < CONSTANTS.GEN.MULT_C);
      
      if (tryMult) {
        const r = Math.random(), val = r<0.1 ? 5 : (r<0.3 ? 3 : 2);
        const mx = p.x + p.w/2, my = p.y-25;
        if (!this.checkOverlap(mx, my)) {
            this.objs.mults.push({ x: mx, y: my, val, dur: Utils.rand(5,10) });
        }
      } else if (this.activeMult.time > 0) {
        const count = this.activeMult.val, spac = CONSTANTS.DIMS.STAR*2, tw = count*spac;
        if (p.w - tw > 0) {
          const start = p.x + Utils.rand(20, p.w - tw - 20);
          for(let i=0; i<count; i++) {
              const sx = start + i*spac + CONSTANTS.DIMS.STAR/2, sy = p.y - 22;
              if(!this.checkOverlap(sx, sy)) this.spawnStar(sx, sy);
          }
        }
      }

      if (!tryMult && Math.random() < CONSTANTS.GEN.STAR_C) {
        const sx = p.x + p.w/2, sy = p.y - 22;
        if(!this.checkOverlap(sx, sy)) this.spawnStar(sx, sy);
      }

      if (idx > 0 && Math.random() < CONSTANTS.GEN.GAP_STAR_C) {
        let prev = this.objs.plats[this.objs.plats.length-2];
        const sx = prev.x + prev.w + gap/2;
        const sy = Utils.clamp((prev.y+p.y)/2 - 80, this.h*0.1, this.h-200);
        if(!this.checkOverlap(sx, sy)) this.spawnStar(sx, sy);
      }
      return p.x + p.w;
    }

    spawnStar(x, y) { 
        this.objs.stars.push({ x, y, s:CONSTANTS.DIMS.STAR, r:Utils.rand(0,6), col:false, anim:0, val: this.activeMult.time > 0 ? this.activeMult.val : 1 }); 
    }
    
    spawnBird() {
      const rare = Math.random()<0.05, pool = rare ? CONSTANTS.COLORS.BIRDS_R : CONSTANTS.COLORS.BIRDS_C;
      this.objs.birds.push({ x:this.w+Utils.rand(50,350), y:Utils.rand(this.h*0.35,this.h*0.55), s:Utils.rand(90,140), flap:0, c:pool[Math.floor(Math.random()*pool.length)] });
    }

    update(dt) {
      if(!this.player.alive) return;
      
      const prevP = this.cycle.get(this.score).p;
      
      if (!this.startDelay) {
        this.speed = Math.min(CONSTANTS.PHYSICS.SPEED_MAX, this.speed + dt * CONSTANTS.PHYSICS.SPEED_INC);
        this.score += (this.speed * dt) * CONSTANTS.PHYSICS.SCORE_MULT;
        this.ui.score.innerText = Math.floor(this.score);
      }
      
      const currP = this.cycle.get(this.score).p;
      this.checkCrackTrigger(prevP, currP);

      const col = this.cycle.get(this.score); 

      // Rare Shooting Stars
      if(!this.shootStar && col.p > 0.55 && col.p < 0.9 && Math.random() < 0.005) {
          this.shootStar = { x:Utils.rand(0,this.w), y:Utils.rand(0,this.h/3), vx:Utils.rand(400,800), vy:Utils.rand(100,200), l:1.5 };
      }
      if(this.shootStar) {
          this.shootStar.x += this.shootStar.vx*dt;
          this.shootStar.y += this.shootStar.vy*dt;
          this.shootStar.l -= dt;
          if(this.shootStar.l <= 0) this.shootStar = null;
      }

      // Grand Magus Particles
      if (this.data.equipped === 'wizardMega') {
         if (Math.random() < 0.3) {
             this.objs.parts.push({
                 x: this.player.x + Utils.rand(0, 36),
                 y: this.player.y + Utils.rand(0, 36),
                 vx: Utils.rand(-20, 20),
                 vy: Utils.rand(-50, -10),
                 l: 0.5,
                 c: Math.random() > 0.5 ? "#ffd700" : "#a020f0"
             });
         }
      }

      if(this.activeMult.time > 0) {
        this.activeMult.time -= dt;
        if(this.activeMult.time <= 0) {
           this.activeMult.val = 1;
           this.ui.mult.className = "";
           this.ui.multTime.innerText = "";
           this.objs.stars.forEach(s => s.val = 1);
        }
      }

      const scroll = this.startDelay ? 0 : this.speed * dt;

      const updL = (list, spd, min, max, type) => {
        for(let m of list) m.x -= this.speed * m.s * dt;
        list = list.filter(m => m.x + m.w > 0);
        const last = list[list.length-1];
        if(last.x + last.w < this.w + 800*0.25) {
           let segs = (type === 'far') ? 8 : 4;
           let y = last.pts[last.pts.length-1].y;
           let segW = last.w / segs;
           let pts = [{x:0,y}];
           let cy = y;
           for(let i=1; i<=segs; i++){
             cy = Utils.clamp(cy + Utils.rand(type==='hills'?-50:-100, type==='hills'?50:100), min, max);
             if(type==='near') cy = Utils.clamp(cy + Utils.rand(-40,40), min, max);
             pts.push({x:i*segW, y:cy});
           }
           let snowNoise = [];
           if(type === 'far') {
             const noiseSteps = Math.ceil(last.w / 10);
             for(let k=0; k<=noiseSteps; k++) snowNoise.push(Utils.rand(-5, 5));
           }
           list.push({x:last.x+last.w-4, w:last.w, pts, s:spd, snowNoise});
        }
        return list;
      };
      this.objs.mtn.f = updL(this.objs.mtn.f, 0.15, this.h-650, this.h-400, 'far');
      this.objs.mtn.n = updL(this.objs.mtn.n, 0.3, this.h-450, this.h-250, 'near');
      this.objs.mtn.h = updL(this.objs.mtn.h, 0.6, this.h-180, this.h-100, 'hills');

      this.objs.clouds.forEach(c => { c.x -= (this.startDelay?0:this.speed*0.12 + c.s*0.02)*dt; if(c.x+200<-100) c.x=this.w+100; });
      this.objs.birds.forEach(b => { b.x -= b.s*dt; b.flap += dt * 5; });
      this.objs.birds = this.objs.birds.filter(b => b.x > -200);
      if(this.objs.birds.length < 4) this.spawnBird();

      this.objs.plats.forEach(p => p.x -= scroll);
      this.objs.plats = this.objs.plats.filter(p => p.x + p.w > -300);
      let right = -999; this.objs.plats.forEach(p => right = Math.max(right, p.x+p.w));
      while(right < this.w + 600) right = this.addPlatform(right, this.objs.plats.length);

      const pBox = {x:this.player.x, y:this.player.y, w:this.player.size, h:this.player.size};

      this.objs.mults.forEach(m => {
        m.x -= scroll;
        if(!m.col && Utils.AABB(pBox, {x:m.x-14,y:m.y-14,w:28,h:28})) {
          m.col = true;
          this.activeMult = { val:m.val, time:m.dur };
          this.ui.multTxt.innerText = `X${m.val} STAR BONUS!`;
          this.ui.multTime.innerText = ""; // Cleared
          this.ui.mult.className = "active";
          this.objs.mults.forEach(o => o.col = true);
          
          const extras = this.activeMult.val - 1;
          const visibleStars = [...this.objs.stars];
          visibleStars.forEach(s => {
              if(s.col) return;
              for(let i=1; i<=extras; i++) {
                  const offset = (Math.ceil(i/2) * 30) * (i%2===0 ? 1 : -1);
                  this.spawnStar(s.x + offset, s.y);
              }
          });
        }
      });
      this.objs.mults = this.objs.mults.filter(m => m.x > -100 && !m.col);

      this.objs.stars.forEach(s => {
        s.x -= scroll;
        if(s.col) {
          s.anim += dt;
          s.y -= (600*dt) - (600 * s.anim * dt); 
          s.r += dt*20;
        } else {
          s.r += dt*3;
          if(Utils.AABB(pBox, {x:s.x-s.s/2,y:s.y-s.s/2,w:s.s,h:s.s})) {
            this.runStars += s.val; 
            this.ui.stars.innerText = this.data.totalStars + this.runStars;
            s.col = true;
            for(let i=0; i<8; i++) this.objs.parts.push({x:s.x, y:s.y, vx:Utils.rand(-150,150), vy:Utils.rand(-250,-50), l:0.6, c:CONSTANTS.COLORS.STAR});
          }
        }
      });
      this.objs.stars = this.objs.stars.filter(s => s.anim < 0.6);

      this.objs.parts.forEach(p => { p.x+=p.vx*dt; p.y+=p.vy*dt; p.l-=dt; });
      this.objs.parts = this.objs.parts.filter(p => p.l > 0);

      if(!this.startDelay) this.player.update(dt, this.objs.plats, CONSTANTS.PHYSICS.GRAVITY);
      
      if(this.player.y > this.h + CONSTANTS.DIMS.DEATH_Z) {
        this.die();
      }
    }

    drawClock(p) {
        const ctx = this.clockCtx;
        const w = 64, h = 64;
        ctx.clearRect(0,0,w,h);
        const cx = w/2, cy = h/2;
        
        const grad = ctx.createLinearGradient(0,0,w,h);
        grad.addColorStop(0, "#DAA520"); grad.addColorStop(1, "#8B4513");
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(cx, cy, 30, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#1a1a2e"; 
        ctx.beginPath(); ctx.arc(cx, cy, 26, 0, Math.PI*2); ctx.fill();

        ctx.save();
        ctx.translate(cx, cy);
        const angle = p * Math.PI * 2;
        ctx.rotate(angle);
        
        ctx.fillStyle = "rgba(135, 206, 235, 0.3)";
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,26, -Math.PI/2, Math.PI/2); ctx.fill();
        
        ctx.fillStyle = "#FFD700";
        ctx.beginPath(); ctx.arc(0, -18, 4, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#FFA500"; ctx.lineWidth=1; ctx.stroke();
        
        ctx.fillStyle = "#FFF";
        ctx.beginPath(); ctx.arc(0, 18, 3, 0, Math.PI*2); ctx.fill();
        
        ctx.restore();

        const glass = ctx.createLinearGradient(0,0,w,h);
        glass.addColorStop(0, "rgba(255,255,255,0.4)"); glass.addColorStop(0.5, "rgba(255,255,255,0)");
        ctx.fillStyle = glass;
        ctx.beginPath(); ctx.arc(cx, cy, 26, 0, Math.PI*2); ctx.fill();
    }

    drawCelestialBodies(p) {
      const ctx = this.ctx;
      const W = this.w;
      const H = this.h;
      
      // Higher arc
      const cx = W / 2;
      const cy = H + 100; 
      const radius = W / 2 + 150;
      
      const angle = (p * 2 * Math.PI) - Math.PI/2;
      
      const sx = cx + Math.cos(angle) * radius;
      const sy = cy + Math.sin(angle) * radius;
      const mx = cx + Math.cos(angle + Math.PI) * radius;
      const my = cy + Math.sin(angle + Math.PI) * radius;

      // Fade logic
      const drawBody = (x, y, color, glow, isSun) => {
          if(y < H + 200) {
              const horizonDist = (H + 200) - y;
              const alpha = Math.min(1, horizonDist / 200); // Fade out near horizon
              
              ctx.globalAlpha = alpha;
              ctx.fillStyle = color;
              ctx.shadowBlur = isSun ? 40 : 20; ctx.shadowColor = glow;
              ctx.beginPath(); ctx.arc(x, y, isSun?40:35, 0, Math.PI*2); ctx.fill();
              
              if(isSun) {
                  ctx.fillStyle = "#FFFFE0";
                  ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI*2); ctx.fill();
              } else {
                  ctx.fillStyle = "rgba(0,0,0,0.1)"; 
                  ctx.beginPath(); ctx.arc(x-10, y-5, 8, 0, Math.PI*2); ctx.fill();
                  ctx.beginPath(); ctx.arc(x+12, y+10, 5, 0, Math.PI*2); ctx.fill();
              }
              ctx.shadowBlur = 0;
              ctx.globalAlpha = 1;
          }
      };

      drawBody(sx, sy, "#FFD700", "orange", true);
      drawBody(mx, my, "#F5F3CE", "white", false);
    }

    draw() {
      const ctx = this.ctx, W = this.w, H = this.h;
      
      // Cutscene Mode
      if (this.inCutscene) {
          ctx.fillStyle = "#000";
          ctx.fillRect(0,0,W,H);
          
          ctx.save();
          // Center on Player
          const pl = this.player;
          const cx = pl.x + pl.size/2;
          const cy = pl.y + pl.size/2;
          
          ctx.translate(W/2, H/2);
          
          // Animation Progress
          this.cutsceneTime += 0.03;
          const progress = Math.min(1, this.cutsceneTime / 4); // 4 seconds duration
          const scale = 1 + Math.pow(progress, 3) * 30; // Zoom heavily at end
          const rot = progress * Math.PI * 4; // Spin 2 times
          
          ctx.scale(scale, scale);
          ctx.rotate(rot);
          ctx.translate(-cx, -cy); // Move world so player is at center
          
          // Draw just the player surroundings for effect
          // Sky
          ctx.fillStyle = "#4b8ce6";
          ctx.fillRect(cx-W, cy-H, W*2, H*2);
          
          // Player
          ctx.fillStyle = CONSTANTS.COLORS.PLAYER; 
          ctx.fillRect(pl.x, pl.y, pl.size, pl.size);
          ctx.shadowColor = "#e6ac00"; ctx.shadowBlur = 10; 
          ctx.strokeRect(pl.x, pl.y, pl.size, pl.size); ctx.shadowBlur = 0;
          
          // Eye Entry
          if (progress >= 1) {
              this.activateFPSMode();
          }
          
          ctx.restore();
          return;
      }

      const col = this.cycle.get(this.score);
      
      this.drawClock(col.p);

      const grad = ctx.createLinearGradient(0,0,0,H);
      grad.addColorStop(0, col.skyTop); grad.addColorStop(0.5, col.skyBot); grad.addColorStop(1, Utils.lerpColor(col.skyBot, "#ffffff", 0.5));
      ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);

      let starAlpha = 0;
      if (col.p > 0.4 && col.p < 0.9) {
          starAlpha = 1;
          if(col.p < 0.55) starAlpha = (col.p - 0.4) * 6.6; 
          if(col.p > 0.85) starAlpha = (0.9 - col.p) * 20; 
      }

      if(starAlpha > 0) {
          ctx.fillStyle = "white";
          this.bgStars.forEach(s => {
              ctx.globalAlpha = s.a * starAlpha;
              ctx.fillRect(s.x*W, s.y*H*0.6, s.s, s.s);
          });
          ctx.globalAlpha = 1;
      }

      this.drawCelestialBodies(col.p);

      if(this.shootStar && starAlpha > 0.5) {
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.globalAlpha = Math.min(1, this.shootStar.l);
          ctx.beginPath();
          ctx.moveTo(this.shootStar.x, this.shootStar.y);
          ctx.lineTo(this.shootStar.x - this.shootStar.vx*0.1, this.shootStar.y - this.shootStar.vy*0.1);
          ctx.stroke();
          ctx.globalAlpha = 1;
      }

      const ca = Utils.lerp(1, 0.2, col.p>0.5?(col.p-0.5)*2:0);
      this.objs.clouds.forEach(c => { 
        ctx.globalAlpha = c.a*ca; 
        ctx.fillStyle = "white";
        c.parts.forEach(p => ctx.fillRect(c.x+p.x, c.y+p.y, p.w, p.h));
      });
      ctx.globalAlpha = 1;

      const drawMtn = (l, c, isFar) => {
        l.forEach(m => {
          const rx = Math.round(m.x);
          ctx.fillStyle = c; 
          ctx.beginPath(); 
          ctx.moveTo(rx, H);
          m.pts.forEach(pt => ctx.lineTo(rx+pt.x, pt.y));
          ctx.lineTo(rx+m.w, H);
          ctx.fill();

          if(isFar) {
             ctx.save();
             ctx.clip(); 
             
             ctx.fillStyle = "#fff";
             // Threshold ~0.35 for high peaks
             const snowThreshold = H * 0.35; 
             
             ctx.beginPath();
             ctx.moveTo(rx, 0); 
             ctx.lineTo(rx + m.w, 0); 
             
             const step = 10;
             const steps = Math.floor(m.w / step);
             for(let i = steps; i >= 0; i--) {
                 const xPos = i * step;
                 const noiseVal = m.snowNoise && m.snowNoise[i] ? m.snowNoise[i] : 0;
                 ctx.lineTo(rx + xPos, snowThreshold + noiseVal);
             }
             
             ctx.closePath();
             ctx.fill();
             ctx.restore();
          }
        });
      };
      drawMtn(this.objs.mtn.f, col.far, true);
      drawMtn(this.objs.mtn.n, col.near, false);

      this.objs.birds.forEach(b => {
        ctx.save(); ctx.translate(b.x, b.y);
        const frame = Math.floor(b.flap) % 2;
        ctx.fillStyle=b.c; ctx.fillRect(0,0,12,8); ctx.fillRect(12,-4,8,8);
        ctx.fillStyle="#ff9800"; ctx.fillRect(20,-4,4,4);
        ctx.fillStyle=b.c; ctx.globalAlpha=0.85; ctx.fillRect(4, frame===0?-8:4, 8, 8);
        ctx.restore();
      });

      drawMtn(this.objs.mtn.h, col.hills, false);

      ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 2;
      this.objs.plats.forEach(p => {
        ctx.fillStyle=CONSTANTS.COLORS.PLAT; ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.fillStyle=CONSTANTS.COLORS.PLAT_TOP; ctx.fillRect(p.x, p.y, p.w, 6);
        ctx.strokeRect(p.x, p.y, p.w, p.h);
      });

      this.objs.mults.forEach(m => {
        const art = AssetFactory.get(m.val.toString());
        if(art) {
           const y = m.y + Math.sin(this.time*4)*5;
           const scale = 4;
           const dw = art.w * scale, dh = art.h * scale;
           ctx.drawImage(art.img, m.x-dw/2, y-dh/2, dw, dh); 
        }
      });

      ctx.fillStyle = CONSTANTS.COLORS.STAR; ctx.shadowColor = CONSTANTS.COLORS.STAR; ctx.lineJoin = "round"; ctx.lineWidth = 4;
      this.objs.stars.forEach(s => {
        ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.r);
        if(s.col) ctx.globalAlpha = Math.max(0, 1-(s.anim/0.5));
        ctx.shadowBlur = s.col ? 0 : 10;
        const sz = s.s + (s.col ? 0 : Math.sin(this.time*5)*2);
        ctx.beginPath();
        for(let i=0, rot=Math.PI/2*3; i<5; i++) {
          ctx.lineTo(Math.cos(rot)*sz/2, Math.sin(rot)*sz/2); rot+=Math.PI/5;
          ctx.lineTo(Math.cos(rot)*sz/4, Math.sin(rot)*sz/4); rot+=Math.PI/5;
        }
        ctx.closePath(); ctx.fill(); ctx.restore();
      });
      ctx.shadowBlur = 0; ctx.globalAlpha = 1;

      this.objs.parts.forEach(p => { ctx.fillStyle = p.c; ctx.globalAlpha = p.l/0.6; ctx.fillRect(p.x, p.y, 4, 4); });
      ctx.globalAlpha = 1;

      const pl = this.player;
      ctx.fillStyle = CONSTANTS.COLORS.PLAYER; ctx.fillRect(pl.x, pl.y, pl.size, pl.size);
      ctx.shadowColor = "#e6ac00"; ctx.shadowBlur = 10; ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 2;
      ctx.strokeRect(pl.x, pl.y, pl.size, pl.size); ctx.shadowBlur = 0;

      if (this.data.equipped) {
        const art = AssetFactory.get(this.data.equipped);
        if (art) {
          const scale = art.h > 10 ? 3 : 4;
          ctx.drawImage(art.img, pl.x + pl.size/2 - (art.w*scale)/2, pl.y - art.h*scale, art.w*scale, art.h*scale);
        }
      }
    }

    loop(now) {
      const dt = Math.min(0.05, (now - this.lastT) / 1000);
      this.lastT = now;

      if (this.crackMode && this.fpsEngine && !this.inCutscene) {
          this.fpsEngine.update(dt);
          this.fpsEngine.draw(this.w, this.h);
      } else {
          if (this.isPaused || (this.dialogOpen && !this.crackMode && !this.inCutscene)) {
            if(this.isPaused) {
               this.pauseTime -= dt;
               this.ui.pauseTimer.innerText = this.pauseTime.toFixed(2);
               if (this.pauseTime <= 0) {
                   this.die();
               }
            }
          } else if (!this.shopOpen && !this.inCutscene) { 
              this.time += dt; 
              this.update(dt); 
          }
          // If we are in cutscene or regular mode, draw 2D
          if(!this.crackMode || this.inCutscene) this.draw();
      }
      
      requestAnimationFrame(this.loop);
    }
  }
  new Game();
})();
</script>
</body>
</html>
