<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>run4fun</title>

<style>
  :root {
    --bg-color: #4b8ce6;
    --font-main: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    --font-display: "Georgia", serif;
    --font-mono: monospace;
    --font-impact: "Impact", sans-serif;

    /* Rarity Colors */
    --r-common: #b0b0b0;    
    --r-uncommon: #2ecc71;  
    --r-rare: #00d4ff;      
    --r-epic: #bd00ff;      
    --r-legendary: #f39c12; 
    --r-mythic: #f1c40f;    
  }

  html, body {
    margin: 0; height: 100%; background: var(--bg-color);
    overflow: hidden; font-family: var(--font-main);
    touch-action: none; user-select: none; -webkit-user-select: none;
  }

  #game { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }

  /* --- UI OVERLAYS --- */
  .ui-layer {
    position: absolute; pointer-events: none; color: white;
    font-weight: bold; text-shadow: 2px 2px 0 #000; z-index: 10;
  }

  /* HUD CONTAINER */
  #hud-container {
    position: absolute; top: 22px; left: 22px;
    transform: none;
    display: flex; gap: 16px;
    z-index: 12; pointer-events: none;
    flex-direction: row;
    align-items: center;
  }

  #hud-stats {
    display: flex; gap: 16px;
    font-family: var(--font-impact);
    letter-spacing: 1px;
    flex-direction: row;
  }

  .hud-box {
    min-width: 120px;
    padding: 8px 14px;
    border-radius: 14px;
    background: rgba(6, 16, 40, 0.45);
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    backdrop-filter: blur(8px);
    display: flex; align-items: center;
    gap: 10px;
    position: relative;
    overflow: hidden;
  }
  
  .hud-box::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.06);
    pointer-events: none;
  }

  .hud-box .hud-icon {
    width: 28px; height: 28px;
    border-radius: 10px;
    display: flex; align-items: center; justify-content: center;
    font-size: 14px;
    background: rgba(255,255,255,0.05);
    box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
  }

  .hud-body { display: flex; flex-direction: column; }
  .hud-label { font-size: 8px; color: rgba(255,255,255,0.5); text-transform: uppercase; }
  .hud-value { font-size: 18px; color: white; text-shadow: 0 0 6px rgba(0,0,0,0.5); }
  #hud-stars .hud-icon { background: rgba(255, 215, 0, 0.15); color: #ffd700; }
  #hud-highscore .hud-icon { background: rgba(102, 217, 255, 0.2); color: #66d9ff; }

  #clock-canvas {
    width: 80px; height: 80px;
    image-rendering: pixelated;
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5));
    border-radius: 50%;
  }

  #overlay-center {
    left: 50%; top: 50%; transform: translate(-50%, -50%);
    font-size: 30px; text-align: center; width: 100%;
    transition: opacity 0.3s ease;
  }

  /* --- MULTIPLIER --- */
  #multiplier-container {
    position: absolute; top: 35%; left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    font-family: var(--font-impact); text-transform: uppercase;
    color: #ffd700; opacity: 0; pointer-events: none; z-index: 12;
    transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    display: flex; flex-direction: column; align-items: center;
  }
  #multiplier-container.active { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  
  #multiplier-text {
    font-size: 50px; font-weight: 900; -webkit-text-stroke: 2px black;
    animation: rainbow 0.5s linear infinite;
  }
  #multiplier-timer { display: none; }

  @keyframes rainbow {
    0% { text-shadow: 0 0 15px #ff0000; } 20% { text-shadow: 0 0 15px #ffff00; }
    40% { text-shadow: 0 0 15px #00ff00; } 60% { text-shadow: 0 0 15px #00ffff; }
    80% { text-shadow: 0 0 15px #0000ff; } 100% { text-shadow: 0 0 15px #ff00ff; }
  }

  @keyframes rainbow-border {
    0% { border-color: #ff0000; box-shadow: 0 0 20px #ff0000; }
    16.67% { border-color: #ffff00; box-shadow: 0 0 20px #ffff00; }
    33.33% { border-color: #00ff00; box-shadow: 0 0 20px #00ff00; }
    50% { border-color: #00ffff; box-shadow: 0 0 20px #00ffff; }
    66.67% { border-color: #0000ff; box-shadow: 0 0 20px #0000ff; }
    83.33% { border-color: #ff00ff; box-shadow: 0 0 20px #ff00ff; }
    100% { border-color: #ff0000; box-shadow: 0 0 20px #ff0000; }
  }

  /* --- SHOP BUTTON --- */
  #shop-btn-wrap {
    position: absolute; top: 20px; right: 20px; z-index: 50;
    cursor: pointer; filter: drop-shadow(0 0 15px rgba(0,0,0,0.5));
    transition: transform 0.1s;
    display: none; 
  }
  #shop-btn-wrap:active { transform: scale(0.95); }
  
  #shop-btn {
    position: relative; background: #000; color: #fff; border: none;
    font-family: var(--font-impact); font-size: 36px; padding: 15px 35px;
    text-transform: uppercase; letter-spacing: 2px; overflow: hidden;
    display: flex; align-items: center; gap: 15px; transform: skewX(-5deg);
  }
  #shop-btn::before {
    content: ''; position: absolute; top: 50%; left: 50%;
    width: 350px; height: 350px; border-radius: 50%;
    background: conic-gradient(#ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080, #ff0000);
    animation: spin 2.5s linear infinite; z-index: 0;
    transform: translate(-50%, -50%);
  }
  #shop-btn::after { content: ''; position: absolute; inset: 6px; background: #000; z-index: 0; }
  #shop-btn > * { position: relative; z-index: 1; transform: skewX(5deg); text-shadow: 0 0 10px rgba(255,255,255,0.5); }
  
  .star-icon { color: #ffff00; animation: pulse 0.5s infinite alternate; }
  @keyframes spin { from { transform: translate(-50%,-50%) rotate(0deg); } to { transform: translate(-50%,-50%) rotate(360deg); } }
  @keyframes pulse { from { transform: skewX(5deg) scale(1); } to { transform: skewX(5deg) scale(1.3); } }

  /* --- SHOP MODAL --- */
  #shop-modal {
    position: absolute; inset: 0; background: rgba(5, 5, 10, 0.98);
    z-index: 100; display: none; flex-direction: column; align-items: center;
    padding: 40px 20px;
    overflow-y: auto;
  }
  #shop-title {
    font-family: var(--font-impact); font-size: 35px; color: white;
    text-transform: uppercase; text-shadow: 3px 3px 0 #bd00ff; letter-spacing: 2px; margin-bottom: 8px;
  }
  #shop-currency {
    color: #ffd700; font-size: 14px; font-family: var(--font-mono);
    padding: 6px 20px; border: 1px solid #ffd700; border-radius: 20px;
    background: rgba(0,0,0,0.5); box-shadow: 0 0 10px rgba(255,215,0,0.2); margin-bottom: 15px;
  }
  #shop-grid {
    display: grid; grid-template-columns: repeat(4, 1fr);
    gap: 15px; width: 100%; max-width: 800px; padding: 20px;
  }
  .shop-item {
    background: linear-gradient(135deg, #2a2a3a, #151520); border: 2px solid #333;
    display: flex; flex-direction: column; align-items: center; padding: 10px;
    cursor: pointer; position: relative; transform: skewX(-5deg);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3); border-bottom-width: 4px; transition: all 0.2s ease;
    min-width: 0;
  }
  .shop-item:hover { transform: scale(1.05) skewX(-5deg); border-color: white; z-index: 2; box-shadow: 0 8px 20px rgba(0,0,0,0.5); }
  
  .shop-item[data-r="common"] { border-bottom-color: var(--r-common); }
  .shop-item[data-r="uncommon"] { border-bottom-color: var(--r-uncommon); }
  .shop-item[data-r="rare"] { border-bottom-color: var(--r-rare); }
  .shop-item[data-r="epic"] { border-bottom-color: var(--r-epic); }
  .shop-item[data-r="legendary"] { border-bottom-color: var(--r-legendary); }
  .shop-item[data-r="mythic"] { 
    border: 2px solid #ff0000;
    box-shadow: 0 0 20px #ff0000;
    animation: rainbow-border 2s linear infinite;
  }
  
  .shop-item.equipped { border-color: #ffd700; box-shadow: 0 0 15px rgba(255,215,0,0.6); }
  .shop-item.equipped::after {
    content: 'EQUIPPED'; position: absolute; top: -10px; background: #ffd700;
    color: black; font-weight: bold; font-size: 10px; padding: 2px 8px; transform: skewX(5deg);
  }
  .item-preview {
    width: 80px; height: 80px; background: rgba(0,0,0,0.3);
    margin-bottom: 8px; display: flex; justify-content: center; align-items: center; 
    border-radius: 4px;
    transform: skewX(5deg);
  }
  .item-preview canvas { width: 70px; height: 70px; image-rendering: pixelated; } 
  
  .item-name { color: white; font-weight: 800; font-size: 12px; margin-bottom: 3px; text-align: center; text-transform: uppercase; transform: skewX(5deg); }
  .shop-item[data-r="mythic"] .item-name { color: var(--r-mythic); }
  .item-price { color: #ffd700; font-size: 11px; font-family: var(--font-mono); font-weight: bold; transform: skewX(5deg); }
  .item-desc {
    margin-top: 3px;
    font-size: 10px;
    color: rgba(255,255,255,0.7);
    text-align: center;
    font-family: var(--font-main);
    transform: skewX(5deg);
    min-height: 24px;
  }

  #shop-close {
    display: none; /* Hidden - click outside items to close shop */
    margin-top: 40px; background: #b00; color: white; border: none;
    padding: 15px 60px; font-size: 24px; font-family: var(--font-impact);
    cursor: pointer; transform: skewX(-10deg); text-transform: uppercase; letter-spacing: 1px;
    transition: background 0.2s;
  }
  #shop-close:hover { background: #d00; }

  /* --- DEATH SCREEN --- */
  #death-screen {
    position: absolute; inset: 0; display: flex; flex-direction: column;
    justify-content: center; align-items: center; background: black;
    opacity: 0; pointer-events: none; transition: opacity 2s ease-in;
    z-index: 20;
  }
  #death-title {
    font-family: "Times New Roman", serif;
    font-size: 100px; 
    color: #8d0808; /* Dark Red */
    text-transform: uppercase;
    letter-spacing: 15px;
    margin-bottom: 30px; 
    text-align: center;
    text-shadow: 0 0 15px rgba(139, 0, 0, 0.6);
    transform: scale(1.2);
    transition: transform 3s ease-out, opacity 1s;
    opacity: 0;
  }
  #death-screen.active #death-title { transform: scale(1); opacity: 1; }
  #death-sub { 
    font-family: "Times New Roman", serif; font-size: 24px; color: #888; 
    letter-spacing: 2px; text-align: center; margin-top: 20px; text-transform: uppercase;
  }

  /* --- PAUSE SCREEN --- */
  #pause-screen {
    position: absolute; inset: 0; background: rgba(0,0,0,0.8);
    display: none; flex-direction: column; justify-content: center; align-items: center;
    z-index: 90; color: white; font-family: var(--font-impact); cursor: pointer;
    backdrop-filter: blur(5px);
  }
  #pause-screen:hover #pause-sub { color: #fff; text-shadow: 0 0 10px white; }
  #pause-title { font-size: 60px; letter-spacing: 5px; margin-bottom: 20px; }
  #pause-timer { font-size: 100px; color: #ff3333; font-family: var(--font-mono); }
  #pause-sub { font-size: 20px; margin-top: 20px; color: #aaa; font-family: var(--font-main); transition: all 0.2s; }

  /* --- CHEAT MODAL --- */
  #cheat-modal {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95); padding: 25px; border: 2px solid #ffd700;
    color: white; font-family: var(--font-mono); z-index: 200; display: none;
    flex-direction: column; gap: 15px; min-width: 320px;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
  }
  .cheat-row { display: flex; justify-content: space-between; align-items: center; }
  .cheat-input { background: #222; color: #0f0; border: 1px solid #555; padding: 5px; width: 100px; font-family: monospace; }
  .cheat-input::-webkit-outer-spin-button, .cheat-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
  .cheat-input { -moz-appearance: textfield; appearance: textfield; }
  .cheat-check { width: 20px; height: 20px; }
  #cheat-close { margin-top: 10px; background: #ffd700; color: black; border: none; padding: 10px; font-weight: bold; cursor: pointer; text-transform: uppercase; }
  #cheat-close:hover { background: #fff; }

  /* --- CRACK MODE POPUP --- */
  .win-popup {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 320px; background: #c0c0c0; border: 2px solid;
    border-color: #fff #000 #000 #fff; box-shadow: 4px 4px 10px rgba(0,0,0,0.5);
    font-family: "Segoe UI", sans-serif; font-size: 14px; color: black;
    display: none; flex-direction: column; z-index: 300;
  }
  .win-header {
    background: #000080; color: white; padding: 3px 6px; font-weight: bold;
    display: flex; justify-content: space-between; align-items: center;
  }
  .win-close {
    background: #c0c0c0; border: 1px solid; border-color: #fff #000 #000 #fff;
    width: 16px; height: 14px; line-height: 12px; text-align: center; color: black;
    cursor: pointer; font-size: 10px; font-family: sans-serif;
  }
  .win-close:active { border-color: #000 #fff #fff #000; }
  .win-body { padding: 20px; display: flex; gap: 15px; align-items: center; }
  .win-icon { 
      width: 32px; height: 32px; background: #f00; border-radius: 50%; 
      display:flex; align-items:center; justify-content:center; 
      color:white; font-weight:bold; font-size:24px; border: 2px solid #800000;
  }
  .win-buttons { padding: 10px; display: flex; justify-content: center; gap: 15px; }
  .win-btn {
    border: 1px solid; border-color: #fff #000 #000 #fff; background: #c0c0c0;
    padding: 5px 25px; cursor: pointer; font-family: sans-serif; min-width: 70px;
  }
  .win-btn:active { border-color: #000 #fff #fff #000; padding: 6px 24px 4px 26px; }

  /* --- CRACK MODE LOADING --- */
  #crack-loading {
    position: absolute; inset: 0; background: #000; color: #0f0; font-family: monospace;
    display: none; flex-direction: column; justify-content: center; align-items: center;
    font-size: 24px; z-index: 301;
  }
  .loading-bar { border: 2px solid #0f0; padding: 2px; width: 300px; height: 20px; margin-top: 20px; }
  .loading-fill { height: 100%; background: #0f0; width: 0%; transition: width 2s linear; }

  /* --- CRACK MODE (FPS) HUD --- */
  #fps-overlay {
    display: none; position: absolute; inset: 0; pointer-events: none; z-index: 50;
    mix-blend-mode: overlay; pointer-events: none;
  }
  
  /* CRY OF FEAR STYLE NOISE & VIGNETTE */
  .grain-overlay {
    position: absolute; inset: 0;
    background-image: url('data:image/svg+xml,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)" opacity="0.15"/%3E%3C/svg%3E');
    opacity: 0.4; pointer-events: none;
    animation: grainShift 0.2s steps(4) infinite;
  }
  @keyframes grainShift { 0% { transform: translate(0,0) } 25% { transform: translate(-5px,5px) } 50% { transform: translate(5px,-5px) } 75% { transform: translate(-5px,-5px) } }

  #touch-btn {
    position: absolute; right: 20px; bottom: 20px; width: 75px; height: 75px;
    border-radius: 50%; background: #ffd42a; display: flex; align-items: center; justify-content: center;
    font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer; z-index: 15; font-size: 24px;
    user-select: none;
  }
  @media (min-width: 700px) { #touch-btn { display: none; } }
  @media (max-width: 600px) { #death-title { font-size: 50px; letter-spacing: 5px; } }
</style>
</head>

<body>
<canvas id="game"></canvas>

<div id="fps-overlay">
<div class="grain-overlay"></div>
</div>

<div id="hud-container">
  <div id="hud-stats">
    <div class="hud-box" id="hud-score">
      <div class="hud-icon">üèÜ</div>
      <div class="hud-body">
        <span class="hud-label">Score</span>
        <span class="hud-value" id="score-val">0</span>
      </div>
    </div>
    <div class="hud-box" id="hud-stars">
      <div class="hud-icon">‚òÖ</div>
      <div class="hud-body">
        <span class="hud-label">Stars</span>
        <span class="hud-value" id="stars-val">0</span>
      </div>
    </div>
    <div class="hud-box" id="hud-highscore">
      <div class="hud-icon">‚¨Ü</div>
      <div class="hud-body">
        <span class="hud-label">Highscore</span>
        <span class="hud-value" id="highscore-val">0</span>
      </div>
    </div>
  </div>
  <canvas id="clock-canvas" width="64" height="64"></canvas>
</div>

<div id="overlay-center" class="ui-layer">Tap / Space to Start</div>

<div id="multiplier-container">
  <div id="multiplier-text">X2 STARS!</div>
  <div id="multiplier-timer"></div> 
</div>

<div id="shop-btn-wrap">
  <button id="shop-btn">
    <div class="star-icon">‚òÖ</div> <span>ITEM SHOP</span> <div class="star-icon">‚òÖ</div>
  </button>
</div>

<div id="shop-modal">
  <div id="shop-title">Item Shop</div>
  <div id="shop-currency">STARS: 0</div>
  <div id="shop-grid"></div>
  <button id="shop-close">Back To Game</button>
</div>

<div id="death-screen">
  <div id="death-title">YOU DIED</div>
  <div id="death-sub"></div> 
</div>

<div id="pause-screen">
  <div id="pause-title">PAUSED</div>
  <div id="pause-timer">20.00</div>
  <div id="pause-sub">CLICK OR ESC TO UNPAUSE</div>
</div>

<div id="touch-btn">‚ñ≤</div>

<!-- CHEAT MENU -->
<div id="cheat-modal">
  <div style="text-align:center; font-weight:bold; margin-bottom:10px; color:#ffd700; font-size: 20px;">/// DEV CONSOLE ///</div>
  <div class="cheat-row"><span>Score:</span> <input type="number" id="c-score" class="cheat-input"></div>
  <div class="cheat-row"><span>Stars:</span> <input type="number" id="c-stars" class="cheat-input"></div>
  <div class="cheat-row"><span>God Mode:</span> <input type="checkbox" id="c-god" class="cheat-check"></div>
  <div class="cheat-row"><span>Fly Mode:</span> <input type="checkbox" id="c-fly" class="cheat-check"></div>
  <button id="cheat-close">APPLY & CLOSE</button>
</div>

<!-- WIN 95 POPUP -->
<div id="win-popup" class="win-popup">
  <div class="win-header"><span>System Message</span><div class="win-close" id="win-x">X</div></div>
  <div class="win-body">
    <div class="win-icon">!</div>
    <div id="win-msg" style="font-weight:bold;">Enable CRACK MODE?</div>
  </div>
  <div class="win-buttons">
    <button class="win-btn" id="win-yes">Yes</button>
    <button class="win-btn" id="win-no">No</button>
  </div>
</div>

<!-- FAKE LOADING -->
<div id="crack-loading">
  <div>ENTERING NIGHTMARE...</div>
  <div class="loading-bar"><div class="loading-fill" id="load-fill"></div></div>
</div>

<script>
(() => {
  /** CONFIG & DATA */
  const PIXEL_DATA = {
    // ITEMS
    cone: { colors: { 1:"#ff6600", 2:"#ffffff" }, map: ["000010000","000010000","000111000","000111000","001111100","001111100","022222220","111111111"] },
    bandana: { colors: { 1:"#8B4513", 2:"#654321", 3:"#DAA520" }, map: ["00111100","01222210","12222221","12233221","01222210","00111100"] },
    beanie: { colors: { 1:"#9b59b6", 2:"#6c3483", 3:"#f8e9ff" }, map: ["000111100","001333110","013333311","111222111","111222111","111111111"] },
    sprout: { colors: { 1:"#81c784", 2:"#558b2f" }, map: ["000010000","000121000","001121100","001111100","011111110","111111111"] },
    visor: { colors: { 1:"#1abc9c", 2:"#117a65", 3:"#ecf0f1" }, map: ["000000000","001111100","011222110","011222110","001333100","000111000"] },
    goggles: { colors: { 1:"#263238", 2:"#90caf9", 3:"#e3f2fd" }, map: ["000000000","111000011","122000021","122000021","133000031","011111110"] },
    cyberglasses: { colors: { 1:"#00ff00", 2:"#00dd00", 3:"#0088ff", 4:"#00ffff" }, map: ["001111100","012222210","122333221","122333221","122333221","012222210","001111100"] },
    fedora: { colors: { 1:"#5d4037", 2:"#3e2723", 3:"#111" }, map: ["000111100","001111110","001121110","011111111","133333333","111111111"] },
    safety: { colors: { 1:"#ffeb3b", 2:"#fbc02d" }, map: ["000111100","001111110","011111111","111222111","111111111","111111111"] },
    afro: { colors: { 1:"#212121", 2:"#424242" }, map: ["001111100","011211110","111112111","112111111","111111211","111111111","011111110"] },
    astro: { colors: { 1:"#eee", 2:"#81d4fa", 3:"#ddd" }, map: ["001111100","011111110","112222211","112222211","112222211","111111111","011333110"] },
    spartan: { colors: { 1:"#daa520", 2:"#c0392b" }, map: ["000022200","000222220","001111110","001111110","011000110","111000111","111000111","011001100"] },
    devil: { colors: { 1:"#d32f2f", 2:"#b71c1c", 3:"#fff" }, map: ["100000001","110000011","110000011","011000110","000000000"] },
    king: { colors: { 1:"#ffd700", 2:"#e91e63", 3:"#00bcd4" }, map: ["100010001","100010001","110111011","111111111","121313121","111111111"] },
    wizardMega: { colors: { 1:"#673ab7", 2:"#4527a0", 3:"#ffd700" }, map: ["00000000212000","00000000212000","0000002112000","00000021131200","00000021111200","00000211311200","00002111111200","00021311113120","00211111111120","02113333333120","21333333333312","11111111111111","13113111131131","11111111111111"] },
    
    // Multipliers
    "2": { colors: { 1: "#ffffff" }, map: ["111000101","001000101","111000010","100000101","111000101"] },
    "3": { colors: { 1: "#ffffff" }, map: ["111000101","001000101","111000010","001000101","111000101"] },
    "5": { colors: { 1: "#ffffff" }, map: ["111000101","100000101","111000010","001000101","111000101"] }
  };

  // Shop inventory with item data: id (pixel art key), name, price (in stars), rarity tier, description
  // Sorted by: rarity (common ‚Üí uncommon ‚Üí rare ‚Üí epic ‚Üí legendary ‚Üí mythic), then price (low to high)
  const SHOP_ITEMS = [
    // Common items
    { id: 'cone', name: 'Traffic Cone', price: 0, rarity: 'common', desc: 'A distinctly orange cone.' },
    { id: 'bandana', name: 'Cowboy Hat', price: 25, rarity: 'common', desc: 'Brown felt crown.' },
    // Uncommon items
    { id: 'safety', name: 'Safety First', price: 100, rarity: 'uncommon', desc: 'Bright and reflective.' },
    { id: 'visor', name: 'Neon Visor', price: 140, rarity: 'uncommon', desc: 'Luminous headwear.' },
    // Rare items
    { id: 'spartan', name: 'Spartan Helm', price: 300, rarity: 'rare', desc: 'Ancient and stoic.' },
    { id: 'afro', name: 'Disco King', price: 420, rarity: 'rare', desc: 'Of another era.' },
    // Epic items
    { id: 'cyberglasses', name: 'Cyber Glasses', price: 900, rarity: 'epic', desc: 'Not quite real.' },
    { id: 'fedora', name: 'Detective Hat', price: 1950, rarity: 'epic', desc: 'Shrouded in mystery.' },
    // Legendary items
    { id: 'king', name: 'Midas Crown', price: 2200, rarity: 'legendary', desc: 'Everything turns to gold.' },
    { id: 'wizardMega', name: 'Grand Magus', price: 2500, rarity: 'legendary', desc: 'Arcane essence.' },
    // Mythic items
    { id: 'astro', name: 'Space Walker', price: 10000, rarity: 'mythic', desc: '...' },
    { id: 'devil', name: 'Lil\' Horns', price: 6666, rarity: 'mythic', desc: '...' }
  ];

  const CONSTANTS = {
    // Physics parameters: gravity acceleration (px/ms¬≤), jump velocity (px/ms), speed values (px/ms)
    PHYSICS: { GRAVITY: 1800, JUMP: -760, SPEED_START: 260, SPEED_MAX: 900, SPEED_INC: 8, SCORE_MULT: 0.15 },
    // Dimensions: player size, platform height, star size (all in pixels), ground offset, death zone threshold
    DIMS: { PLAYER: 36, PLAT_H: 24, STAR: 24, GROUND_OFF: 140, DEATH_Z: 100 },
    // Generation parameters: gap ranges (px), platform width ranges (px), vertical variation (px), spawn chances
    GEN: { 
        GAP: {MIN:80, MAX:400},        // Vertical gap between platforms
        WIDTH: {MIN:260, MAX:480},     // Platform width variation
        Y_VAR: {MIN:-50, MAX:90},      // Vertical position variation
        STAR_C: 0.4,                   // Star spawn chance (40%)
        GAP_STAR_C: 0.1,               // Star in gap chance (10%)
        MULT_C: 0.06,                  // Multiplier spawn chance (6%)
        CYCLE: 15000                   // World theme cycle duration (15 seconds)
    },
    // Color palette: platforms, player, stars, birds
    COLORS: { PLAT: "#5d4037", PLAT_TOP: "#4caf50", PLAYER: "#ffd42a", STAR: "#ffd700", BIRDS_C: ["#f0f8ff","#808080","#333333"], BIRDS_R: ["#aeea00","#ff0055","#00ccff"] }
  };

  const WORLD_THEMES = {
    normal: {
      platform: { body: CONSTANTS.COLORS.PLAT, top: CONSTANTS.COLORS.PLAT_TOP },
      star: CONSTANTS.COLORS.STAR,
      player: CONSTANTS.COLORS.PLAYER
    },
    hell: {
      skyTop: "#2d0202",
      skyBot: "#0c0000",
      far: "#4a0505",
      near: "#7a1111",
      hills: "#a41c1c",
      platform: { body: "#3b0707", top: "#ff5f1f" },
      star: "#ffdd66",
      player: "#ffb347"
    },
    moon: {
      skyTop: "#050d24",
      skyBot: "#102041",
      far: "#0b2447",
      near: "#1f4690",
      hills: "#3a6ea5",
      platform: { body: "#9aa4c7", top: "#e6efff" },
      star: "#c2f6ff",
      player: "#fff6c2"
    },
    noir: {
      skyTop: "#0f141b",
      skyBot: "#1b1f2c",
      far: "#0b0d15",
      near: "#161821",
      hills: "#1e2029",
      platform: { body: "#22232c", top: "#2f313c" },
      star: "#f1f1f1",
      player: "#f7f7f0"
    },
    disco: {
      skyTop: "#480ca8",
      skyBot: "#03045e",
      far: "#240046",
      near: "#560bad",
      hills: "#7209b7",
      platform: { body: "#1f1a3d", top: "#8ac4ff" },
      star: "#ffd166",
      player: "#fefefe"
    },
    spartan: {
      skyTop: "#5b0f0f",
      skyBot: "#b62319",
      far: "#330909",
      near: "#761212",
      hills: "#8c2a16",
      platform: { body: "#4a1f0f", top: "#c87f28" },
      star: "#ffdf8c",
      player: "#ffe2a8"
    }
  };

  const HAT_OVERLAYS = new Set(['astro', 'spartan', 'cyberglasses']);
  const HAT_OVERLAY_CONFIG = {
    astro: { offsetY: 6 },
    spartan: { offsetY: 12 },
    cyberglasses: { offsetY: 10 }
  };
  const MIDAS_CONFIG = { passiveRate: 2.5, passiveAmount: 2, starBonus: 4 };

  /** UTILITIES - Helper functions for math, colors, collision, and random values */
  const Utils = {
    // Generate random float between a and b (inclusive)
    rand: (a, b) => Math.random() * (b - a) + a,
    // Generate random integer between a and b (inclusive)
    randInt: (a, b) => Math.floor(Math.random() * (b - a + 1)) + a,
    // Constrain value v between bounds a and b
    clamp: (v, a, b) => Math.max(a, Math.min(b, v)),
    // Linear interpolation between a and b with parameter t (0-1)
    lerp: (a, b, t) => a + (b - a) * t,
    // Interpolate between two hex colors based on amount (0-1)
    lerpColor: (a, b, amount) => {
      const ah = parseInt(a.slice(1), 16), bh = parseInt(b.slice(1), 16);
      const ar = ah>>16, ag = (ah>>8)&0xff, ab = ah&0xff, br = bh>>16, bg = (bh>>8)&0xff, bb = bh&0xff;
      return '#' + ((1<<24) + ((ar+(br-ar)*amount)<<16) + ((ag+(bg-ag)*amount)<<8) + (ab+(bb-ab)*amount|0)).toString(16).slice(1);
    },
    // Convert hex color to grayscale using luminance formula
    toGray: (hex) => {
      const val = parseInt(hex.slice(1), 16);
      const r = val >> 16, g = (val >> 8) & 0xff, b = val & 0xff;
      const avg = Math.round(0.3 * r + 0.59 * g + 0.11 * b);
      const part = (avg << 16) | (avg << 8) | avg;
      return `#${part.toString(16).padStart(6, '0')}`;
    },
    // Return true with probability p (0-1)
    chance: (p) => Math.random() < p,
    // AABB collision detection: returns true if rectangles r1 and r2 overlap
    AABB: (r1, r2) => r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y
  };

  // StorageManager: Handles persistent game data using browser localStorage
  const StorageManager = {
    KEY: 'run4fun_save_v11', // Unique key for this game's save data
    // Load game state from localStorage or return default values
    load: () => {
      const defaults = { totalStars: 0, unlocked: ['cone'], equipped: null, highScore: 0 };
      try { 
          let data = JSON.parse(localStorage.getItem(StorageManager.KEY));
          if(!data || !data.unlocked) return defaults;
          return { ...defaults, ...data };
      }
      catch { return defaults; }
    },
    // Save game state to localStorage
    save: (data) => localStorage.setItem(StorageManager.KEY, JSON.stringify(data))
  };

  // AssetFactory: Converts pixel art data into canvas-based sprite assets
  const AssetFactory = {
    cache: {}, // Cached canvas elements for each item
    // Initialize all pixel art sprites from PIXEL_DATA
    init() {
      Object.keys(PIXEL_DATA).forEach(key => {
        this.cache[key] = this.createCanvas(PIXEL_DATA[key]);
      });
    },
    // Convert pixel art object (colors + map) into a canvas element
    createCanvas(art) {
      const rows = art.map.length, cols = art.map[0].length;
      const cvs = document.createElement('canvas');
      cvs.width = cols; cvs.height = rows;
      const ctx = cvs.getContext('2d');
      for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
          if(art.map[r][c] !== '0') {
            ctx.fillStyle = art.colors[art.map[r][c]];
            ctx.fillRect(c, r, 1, 1);
          }
        }
      }
      return { img: cvs, w: cols, h: rows };
    },
    // Retrieve cached canvas for an item id
    get(id) { return this.cache[id]; }
  };

  /** TEXTURE GENERATOR */
  const TextureGen = {
      createConcrete(w, h) {
          const c = document.createElement('canvas'); c.width=w; c.height=h;
          const ctx = c.getContext('2d');
          ctx.fillStyle = '#333'; ctx.fillRect(0,0,w,h);
          for(let i=0; i<w*h*0.8; i++) {
              ctx.fillStyle = Math.random()>0.5 ? 'rgba(0,0,0,0.3)' : 'rgba(100,100,100,0.1)';
              ctx.fillRect(Math.random()*w, Math.random()*h, 2, 2);
          }
          return c;
      },
      createBrick(w, h) {
          const c = document.createElement('canvas'); c.width=w; c.height=h;
          const ctx = c.getContext('2d');
          ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0,0,w,h);
          ctx.fillStyle = '#3a2a2a'; 
          for(let y=0; y<h; y+=16) {
              for(let x=0; x<w; x+=32) {
                  let off = (y/16)%2 === 0 ? 0 : 16;
                  ctx.fillRect(x+off+1, y+1, 30, 14);
              }
          }
          return c;
      }
  };

  /** FPS MODE ENGINE (RAYCASTER) */
  class RaycasterEngine {
      constructor(cvs) {
          this.cvs = cvs;
          this.ctx = cvs.getContext('2d');
          this.mapW = 24;
          this.mapH = 24;
          this.map = [];
          this.texSize = 64;
          this.player = { x: 12, y: 12, dir: 0, pitch: 0, plane: {x:0, y:0.95} }; // FOV ~80deg
          this.flashlightOn = true;
          this.bobPhase = 0;
          
          this.inventory = [
              {id: 'gun', name: 'Glock-19'}, 
              {id: 'knife', name: 'Kitchen Knife'}, 
              {id: 'flashlight', name: 'Hvy Flashlight'}
          ];
          this.activeSlot = 0;

          // Generate Textures
          this.textures = [
              TextureGen.createConcrete(64,64),
              TextureGen.createBrick(64,64)
          ];

          // Tighter Map Generation (Corridors)
          for(let y=0; y<this.mapH; y++) {
              let row = [];
              for(let x=0; x<this.mapW; x++) {
                  if(x===0||x===this.mapW-1||y===0||y===this.mapH-1) {
                      row.push(1);
                  } else if (x%2===0 && Math.random()>0.3) {
                      row.push(2);
                  } else {
                      row.push(0);
                  }
              }
              this.map.push(row);
          }
          this.map[12][12] = 0; this.map[12][13]=0; this.map[13][12]=0;
          
          this.keys = {w:false, a:false, s:false, d:false};
          window.addEventListener('keydown', e => this.key(e, true));
          window.addEventListener('keyup', e => this.key(e, false));
          
          document.addEventListener("mousemove", (e) => {
              if(document.pointerLockElement === this.cvs) {
                  this.player.dir += e.movementX * 0.002; // X Reversed
                  this.player.pitch -= e.movementY * 1.5;
                  this.player.pitch = Math.max(-200, Math.min(200, this.player.pitch)); 
              }
          });
      }

      key(e, state) {
          const k = e.code;
          if(k==='KeyW') this.keys.w = state;
          if(k==='KeyS') this.keys.s = state;
          if(k==='KeyA') this.keys.a = state;
          if(k==='KeyD') this.keys.d = state;
          
          if(state && k==='KeyF') this.flashlightOn = !this.flashlightOn;
          if(state && k.startsWith('Digit')) {
              const n = parseInt(k.replace('Digit','')) - 1;
              if(n >= 0 && n < 9) this.activeSlot = Math.min(n, this.inventory.length-1);
          }
      }

      update(dt) {
          const moveSpeed = 4.0 * dt; // Slower, heavier
          
          // Rotation Vectors
          const dx = Math.cos(this.player.dir) * moveSpeed;
          const dy = Math.sin(this.player.dir) * moveSpeed;
          const sx = Math.cos(this.player.dir + Math.PI/2) * moveSpeed;
          const sy = Math.sin(this.player.dir + Math.PI/2) * moveSpeed;
          
          let nx = this.player.x, ny = this.player.y;
          let moving = false;

          if(this.keys.w) { nx += dx; ny += dy; moving=true; }
          if(this.keys.s) { nx -= dx; ny -= dy; moving=true; }
          if(this.keys.a) { nx -= sx; ny -= sy; moving=true; } // Swapped A/D
          if(this.keys.d) { nx += sx; ny += sy; moving=true; } 
          
          // Simple Collision
          if(this.map[Math.floor(ny)][Math.floor(this.player.x)] === 0) this.player.y = ny;
          if(this.map[Math.floor(this.player.y)][Math.floor(nx)] === 0) this.player.x = nx;

          // Head Bob
          if(moving) {
              this.bobPhase += dt * 10;
          } else {
              this.bobPhase = 0; // Reset to center? Or smoothly dampen. Just reset for now.
          }
      }

      draw(w, h) {
          // Head Bob Offset
          const bobY = Math.sin(this.bobPhase) * 10;
          const bobX = Math.cos(this.bobPhase/2) * 5;

          // Sky/Floor Clearing
          this.ctx.fillStyle = '#000';
          this.ctx.fillRect(0, 0, w, h);
          
          const horizon = h/2 + this.player.pitch + bobY;

          // Textured Raycasting Loop
          for(let x = 0; x < w; x += 2) { // Resolution 2px for performance/style
              const cameraX = 2 * x / w - 1;
              const rayDirX = Math.cos(this.player.dir) + this.player.plane.x * cameraX;
              const rayDirY = Math.sin(this.player.dir) + this.player.plane.y * cameraX;
              
              let mapX = Math.floor(this.player.x);
              let mapY = Math.floor(this.player.y);
              let sideDistX, sideDistY;
              
              const deltaDistX = Math.abs(1/rayDirX);
              const deltaDistY = Math.abs(1/rayDirY);
              let perpWallDist;
              
              let stepX, stepY;
              let hit = 0;
              let side; // 0 for NS, 1 for EW
              let texNum = 0;
              
              if(rayDirX < 0) { stepX = -1; sideDistX = (this.player.x - mapX) * deltaDistX; }
              else { stepX = 1; sideDistX = (mapX + 1.0 - this.player.x) * deltaDistX; }
              if(rayDirY < 0) { stepY = -1; sideDistY = (this.player.y - mapY) * deltaDistY; }
              else { stepY = 1; sideDistY = (mapY + 1.0 - this.player.y) * deltaDistY; }
              
              while(hit === 0) {
                  if(sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                  else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                  if(this.map[mapY][mapX] > 0) {
                      hit = 1;
                      texNum = this.map[mapY][mapX] - 1;
                  }
              }
              
              if(side === 0) perpWallDist = (mapX - this.player.x + (1 - stepX) / 2) / rayDirX;
              else perpWallDist = (mapY - this.player.y + (1 - stepY) / 2) / rayDirY;
              
              const lineHeight = Math.floor(h / perpWallDist);
              const drawStart = -lineHeight / 2 + h / 2 + this.player.pitch + bobY;
              
              // Texture X calc
              let wallX;
              if (side == 0) wallX = this.player.y + perpWallDist * rayDirY;
              else           wallX = this.player.x + perpWallDist * rayDirX;
              wallX -= Math.floor(wallX);
              
              let texX = Math.floor(wallX * 64);
              if(side == 0 && rayDirX > 0) texX = 64 - texX - 1;
              if(side == 1 && rayDirY < 0) texX = 64 - texX - 1;

              // Lighting Calculation
              let lightIntensity = 0;
              if(this.flashlightOn) {
                  // Circle Logic: Screen Space
                  const cx = w/2;
                  const cy = h/2;
                  // Approximating hit point on screen
                  const distToCenter = Math.sqrt(Math.pow(x-cx, 2));
                  
                  if(distToCenter < 300) { // Large Circle
                      const falloff = 1 - (distToCenter/300);
                      // Inverse Square Law proxy for distance
                      const distAtten = 1.0 / (perpWallDist * 0.5 + 0.1);
                      lightIntensity = Math.min(1.2, distAtten * falloff * 3.0); 
                  } else {
                      lightIntensity = 0; // Pitch black outside cone
                  }
              } else {
                  // Ambient
                  lightIntensity = Math.max(0, 0.1 - perpWallDist*0.05);
              }
              
              // Draw Vertical Strip
              // We draw a slice of the texture. 
              // Performance Hack: Draw full strip from a pattern/image? 
              // Native canvas doesn't support 'draw texture column' easily without drawImage loop.
              // Using drawImage for every 2px slice is heavy but manageable for low res.
              
              const tex = this.textures[texNum % this.textures.length];
              
              // Darken by side
              this.ctx.globalAlpha = 1.0;
              // Draw Texture Slice
              this.ctx.drawImage(tex, texX, 0, 1, 64, x, drawStart, 2, lineHeight);
              
              // Apply Lighting (Black overlay with alpha)
              const darkness = 1.0 - lightIntensity;
              if(darkness > 0) {
                  this.ctx.fillStyle = `rgba(0,0,0,${Math.min(1, darkness)})`;
                  this.ctx.fillRect(x, drawStart, 2, lineHeight);
              }
          }
          
          this.drawUI(w, h, bobX, bobY);
      }

      drawUI(w, h, bx, by) {
          const ctx = this.ctx;
          const item = this.inventory[this.activeSlot];
          
          // 3D sway effect on UI
          const swayX = -bx * 2; 
          const swayY = -by * 2;

          ctx.save();
          ctx.translate(swayX, swayY);

          // HANDS: Left Hand (Phone/Light/Support)
          ctx.fillStyle = "#080808"; // Hoodie sleeve
          ctx.fillRect(40, h-180, 80, 200);
          ctx.fillStyle = "#dcb"; // Skin
          ctx.fillRect(50, h-210, 50, 40); 
          // Phone/Device glow?
          ctx.fillStyle = "#acf"; 
          ctx.fillRect(60, h-200, 10, 20);

          // RIGHT HAND (Weapon)
          ctx.translate(w - 220, h - 250);
          
          // Sleeve
          ctx.fillStyle = "#0a0a0a";
          ctx.beginPath();
          ctx.moveTo(50, 250); ctx.lineTo(150, 250); ctx.lineTo(130, 100); ctx.lineTo(70, 100);
          ctx.fill();
          
          // Hand
          ctx.fillStyle = "#dcb";
          ctx.fillRect(70, 80, 60, 50);

          if(item) {
              if(item.id === 'gun') {
                  // Low Poly Glock - Dark Grey/Black
                  ctx.fillStyle = "#222";
                  ctx.fillRect(60, 40, 20, 60); // Grip
                  ctx.fillStyle = "#111";
                  ctx.fillRect(40, 40, 100, 25); // Barrel
                  ctx.fillStyle = "#444"; // Highlight
                  ctx.fillRect(40, 40, 100, 5);
              } else if (item.id === 'knife') {
                  // Kitchen Knife
                  ctx.translate(80, 80);
                  ctx.rotate(-0.5);
                  ctx.fillStyle = "#3e2723";
                  ctx.fillRect(0, 0, 20, 60); // Handle
                  ctx.fillStyle = "#ccc"; // Blade
                  ctx.beginPath();
                  ctx.moveTo(0,0); ctx.lineTo(20,0); ctx.lineTo(10, -80); 
                  ctx.fill();
                  ctx.fillStyle = "rgba(100,0,0,0.5)"; // Rust/Blood
                  ctx.beginPath(); ctx.arc(10, -40, 5, 0, Math.PI*2); ctx.fill();
              } else if (item.id === 'flashlight') {
                  // Heavy Metal Flashlight
                  ctx.translate(60, 60);
                  ctx.rotate(-0.2);
                  ctx.fillStyle = "#222";
                  ctx.fillRect(0, 0, 30, 100);
                  ctx.fillStyle = "#111";
                  ctx.fillRect(-10, -20, 50, 30); // Head
                  if(this.flashlightOn) {
                      ctx.fillStyle = "rgba(255,255,200,0.8)";
                      ctx.fillRect(-5, -25, 40, 5);
                  }
              }
          }
          ctx.restore();

          // INVENTORY (Minimalist/Gritty)
          const slotSize = 40;
          const startX = 20;
          const startY = h - 100;
          
          // Vertical List for "Survival" feel
          ctx.font = "12px Courier New";
          ctx.textAlign = "left";
          
          for(let i=0; i<this.inventory.length; i++) {
              const isSel = (i === this.activeSlot);
              const y = startY + i*25;
              
              if(isSel) {
                  ctx.fillStyle = "rgba(200, 0, 0, 0.6)";
                  ctx.fillRect(startX, y, 150, 20);
                  ctx.fillStyle = "#fff";
                  ctx.fillText("> " + this.inventory[i].name, startX + 5, y+14);
              } else {
                  ctx.fillStyle = "rgba(0,0,0,0.5)";
                  ctx.fillRect(startX, y, 150, 20);
                  ctx.fillStyle = "#888";
                  ctx.fillText("  " + this.inventory[i].name, startX + 5, y+14);
              }
          }
          
          // Offhand Text
          ctx.fillStyle = "#888";
          ctx.fillText("[OFFHAND: EMPTY]", w - 120, h - 30);
          
          // Flashlight Battery UI hint
          if(this.flashlightOn) {
              ctx.fillStyle = "#ffeb3b";
              ctx.fillText("LIGHT: ON", w - 120, h - 50);
          }
      }
  }

  /** GAME CLASSES */
  class Player {
    constructor(groundY) {
      this.size = CONSTANTS.DIMS.PLAYER;
      this.x = 150;
      this.y = groundY - this.size;
      this.vy = 0;
      this.maxJumps = 2;
      this.jumps = this.maxJumps;
      this.alive = true;
    }
    update(dt, platforms, gravity, onLand) {
      if (!this.alive) return;
      this.vy += gravity * dt;
      this.y += this.vy * dt;
      const b = this.y + this.size, r = this.x + this.size;
      
      for (const p of platforms) {
        if (r > p.x && this.x < p.x + p.w) {
          const prevY = b - (this.vy * dt);
          if (prevY <= p.y + 5 && b >= p.y && this.vy >= 0) {
            this.y = p.y - this.size;
            this.vy = 0;
            this.jumps = this.maxJumps;
            if(onLand) onLand(p);
          }
        }
      }
    }
    jump() {
      if (this.jumps > 0) { this.vy = CONSTANTS.PHYSICS.JUMP; this.jumps--; }
    }
  }

  class DayNightCycle {
    constructor() {
      this.sky = [
        {p:0.0, t:"#004e92", b:"#4ca1af"},
        {p:0.35, t:"#004e92", b:"#4ca1af"},
        {p:0.45, t:"#ff6b00", b:"#ffb457"},
        {p:0.55, t:"#000033", b:"#1e3a8a"},
        {p:0.85, t:"#000033", b:"#1e3a8a"},
        {p:0.95, t:"#ffcc80", b:"#ff9068"},
        {p:1.0, t:"#004e92", b:"#4ca1af"}
      ];
      this.mtn = [
        {p:0.0, f:"#2c3e50", n:"#34495e", h:"#455a64"},
        {p:0.45, f:"#5a3a2a", n:"#6d4e3e", h:"#806653"},
        {p:0.55, f:"#1a1a2e", n:"#282a4a", h:"#3e4064"},
        {p:0.85, f:"#1a1a2e", n:"#282a4a", h:"#3e4064"},
        {p:0.95, f:"#5a3a2a", n:"#6d4e3e", h:"#806653"},
        {p:1.0, f:"#2c3e50", n:"#34495e", h:"#455a64"}
      ];
    }
    get(score) {
      const p = (score % CONSTANTS.GEN.CYCLE) / CONSTANTS.GEN.CYCLE;
      const solve = (arr) => {
        let i = 0; while(i<arr.length-1 && p > arr[i+1].p) i++;
        const t = (p - arr[i].p) / (arr[Math.min(arr.length-1, i+1)].p - arr[i].p);
        return { s: arr[i], e: arr[Math.min(arr.length-1, i+1)], t };
      };
      const s = solve(this.sky), m = solve(this.mtn);
      return {
        skyTop: Utils.lerpColor(s.s.t, s.e.t, s.t), skyBot: Utils.lerpColor(s.s.b, s.e.b, s.t),
        far: Utils.lerpColor(m.s.f, m.e.f, m.t), near: Utils.lerpColor(m.s.n, m.e.n, m.t), hills: Utils.lerpColor(m.s.h, m.e.h, m.t),
        p
      };
    }
  }

  class Game {
    constructor() {
      this.cvs = document.getElementById("game");
      this.ctx = this.cvs.getContext("2d", { alpha: false });
      this.ui = {
        score: document.getElementById("score-val"), stars: document.getElementById("stars-val"), highScore: document.getElementById("highscore-val"),
        clock: document.getElementById("clock-canvas"),
        overlay: document.getElementById("overlay-center"), death: document.getElementById("death-screen"), deathSub: document.getElementById("death-sub"),
        shop: document.getElementById("shop-modal"), shopGrid: document.getElementById("shop-grid"), shopStars: document.getElementById("shop-currency"),
        mult: document.getElementById("multiplier-container"), multTxt: document.getElementById("multiplier-text"), multTime: document.getElementById("multiplier-timer"),
        shopBtn: document.getElementById("shop-btn-wrap"), closeShop: document.getElementById("shop-close"), touch: document.getElementById("touch-btn"),
        pause: document.getElementById("pause-screen"), pauseTimer: document.getElementById("pause-timer"),
        cheat: document.getElementById("cheat-modal"), winPopup: document.getElementById("win-popup"),
        winMsg: document.getElementById("win-msg"), crackLoad: document.getElementById("crack-loading"), loadFill: document.getElementById("load-fill"),
        fpsHud: document.getElementById("fps-overlay")
      };
      this.clockCtx = this.ui.clock.getContext("2d");
      
      this.cheats = { god: false, fly: false };
      this.crackMode = false;
      this.crackDenials = 0;
      this.dialogOpen = false;
      this.cutsceneTime = 0;
      this.inCutscene = false;

      this.cycle = new DayNightCycle();
      this.data = StorageManager.load();
      if (typeof this.data.highScore !== 'number') this.data.highScore = 0;
      AssetFactory.init();
      
      this.worldTheme = 'normal';
      this.hellWorldActive = false;
      this.hellResurrectionUsed = false;
      this.spaceJourneyActive = false;
      this.weather = { rain: [] };
      this.weather.rainTimer = 0;
      this.passiveFloaters = [];
      this.discoPulse = 0;
      this.midasPassiveTimer = 0;
      this.magusCooldownMax = 25;
      this.magusCooldown = 0;
      this.prevMagusCooldown = 0;
      this.prevPlayerJumps = 2;
      this.magusShield = 0;
      this.magusFlash = 0;
      this.magusSigils = [];
      this.cowCooldown = 0;
      this.overlayMessageTime = 0;
      this.noirBackdropCache = null;
      this.orbit = null;
      this.currentCycle = this.cycle.get(0);

      this.loop = this.loop.bind(this);
      window.addEventListener("resize", () => this.resize());
      
      const input = (e) => {
        if (e.code === "Escape") { this.togglePause(); return; }
        if (e.code === "KeyC") { this.toggleCheat(); return; }
        
        if(this.crackMode && this.fpsEngine) {
            return; 
        }

        if(this.shopOpen || this.isPaused || this.dialogOpen || this.inCutscene) return;
        if(e.type === 'keydown' && (e.code!=="Space" && e.code!=="KeyW")) return;
        if(e.preventDefault) e.preventDefault(); 
        this.handleInput();
      };
      window.addEventListener("keydown", input);
      window.addEventListener("pointerdown", (e) => {
        if(this.crackMode) {
            this.cvs.requestPointerLock();
            return;
        }
        if(e.target.closest('#shop-modal') || e.target.closest('#shop-btn-wrap') || e.target.closest('#cheat-modal') || e.target.closest('.win-popup')) return;
        input(e);
      });

      this.ui.shopBtn.addEventListener("click", () => this.toggleShop(true));
      this.ui.closeShop.addEventListener("click", () => this.toggleShop(false));
      
      // Click on shop modal background (not items) to close shop
      this.ui.shop.addEventListener("click", (e) => {
        if (e.target === this.ui.shop) {
          this.toggleShop(false);
        }
      });
      
      this.ui.pause.addEventListener("click", () => this.togglePause());

      document.getElementById("cheat-close").onclick = () => this.applyCheats();
      
      document.getElementById("win-yes").onclick = () => this.enableCrackMode();
      const closeFunc = () => this.denyCrackMode();
      document.getElementById("win-no").onclick = closeFunc;
      document.getElementById("win-x").onclick = closeFunc;

      this.resize();
      this.reset();
      this.updateShop();
      requestAnimationFrame(this.loop);
    }

    handleInput() {
      if (!this.player.alive) { this.reset(); return; }
      if (this.startDelay) {
        this.startDelay = false;
        this.ui.overlay.style.opacity = 0;
        this.ui.shopBtn.style.display = "none";
        this.player.jumps = this.player.maxJumps;
        return;
      }
      if (this.cheats.fly) {
          this.player.vy = CONSTANTS.PHYSICS.JUMP; 
      } else {
          // Detect triple jump (3rd jump before landing)
          if (this.player.jumps === 1 && this.player.maxJumps === 3) {
            // Spawning 3rd jump particles
            const centerX = this.player.x + this.player.size/2;
            const centerY = this.player.y + this.player.size;
            for (let i = 0; i < 16; i++) {
              const angle = (i / 16) * Math.PI * 2;
              const speed = 200;
              this.objs.parts.push({
                x: centerX,
                y: centerY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                l: 0.5,
                c: "#ffed4e"
              });
            }
          }
          this.player.jump();
      }
    }

    toggleCheat() {
        if(this.dialogOpen) return;
        const s = this.ui.cheat.style.display === "flex";
        this.ui.cheat.style.display = s ? "none" : "flex";
        this.dialogOpen = !s;
        
        if(!s) { 
            document.getElementById("c-score").value = Math.floor(this.score);
            document.getElementById("c-stars").value = this.data.totalStars;
            document.getElementById("c-god").checked = this.cheats.god;
            document.getElementById("c-fly").checked = this.cheats.fly;
        }
    }

    applyCheats() {
        this.score = parseInt(document.getElementById("c-score").value) || this.score;
        this.data.totalStars = parseInt(document.getElementById("c-stars").value) || this.data.totalStars;
        this.cheats.god = document.getElementById("c-god").checked;
        this.cheats.fly = document.getElementById("c-fly").checked;
        
        StorageManager.save(this.data);
        this.ui.stars.innerText = this.data.totalStars + this.runStars;
        this.ui.cheat.style.display = "none";
        this.dialogOpen = false;
    }

    togglePause() {
        if (!this.player.alive || this.startDelay || this.shopOpen || this.dialogOpen || this.inCutscene) return;
        this.isPaused = !this.isPaused;
        this.ui.pause.style.display = this.isPaused ? "flex" : "none";
    }

    die() {
        if (this.cheats.god) return; 

        if (this.isHatActive('wizardMega') && this.magusCooldown <= 0) {
            this.triggerMagusSave();
            return;
        }

        if (this.isHatActive('devil') && !this.hellResurrectionUsed) {
            this.enterHellWorld();
            return;
        }

        this.player.alive = false;
        this.finalizeRunTotals();
        this.ui.death.style.opacity = 1;
        this.ui.death.className = "active"; 
        this.ui.death.style.pointerEvents = "auto";
        this.ui.deathSub.innerText = "Press Space to Restart";
        this.isPaused = false;
        this.ui.pause.style.display = "none";
        
        setTimeout(() => {
            if(!this.player.alive) this.ui.shopBtn.style.display = "block";
        }, 3000); 

        this.ui.mult.className = "";
        this.ui.multTime.innerText = "";
    }

    dieMidas() {
      // Special Midas Crown death - day cycle completed
      this.player.alive = false;
      this.finalizeRunTotals();
      this.ui.death.style.opacity = 1;
      this.ui.death.className = "active"; 
      this.ui.death.style.pointerEvents = "auto";
      this.ui.death.innerText = "MIDAS' CURSE";
      this.ui.deathSub.innerText = "Greed consumed him as day turned to night.\nPress Space to Restart";
      this.isPaused = false;
      this.ui.pause.style.display = "none";
      
      setTimeout(() => {
          if(!this.player.alive) this.ui.shopBtn.style.display = "block";
      }, 3000);
      
      this.ui.mult.className = "";
      this.ui.multTime.innerText = "";
      
      // Spawn golden particles around player
      for (let i = 0; i < 40; i++) {
        const angle = (i / 40) * Math.PI * 2;
        const speed = 250;
        this.objs.parts.push({
          x: this.player.x + this.player.size/2,
          y: this.player.y + this.player.size/2,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          l: 1.2,
          c: "#ffd700"
        });
      }
    }

    toggleShop(open) {
      if(this.isPaused || this.dialogOpen) return;
      this.shopOpen = open;
      this.ui.shop.style.display = open ? 'flex' : 'none';
      this.ui.shopBtn.style.display = open ? 'none' : 'block';
      this.ui.mult.style.display = open ? 'none' : 'flex';
      if(open) this.updateShop();
    }

    isHatActive(id) {
      return this.data.equipped === id;
    }

    showOverlayMessage(text, duration=1.5) {
      this.overlayMessageTime = duration;
      this.ui.overlay.innerText = text;
      this.ui.overlay.style.opacity = 1;
    }

    updateShop() {
      this.ui.shopStars.innerText = "STARS: " + this.data.totalStars;
      this.ui.shopGrid.innerHTML = '';
      SHOP_ITEMS.forEach(item => {
        const owned = this.data.unlocked.includes(item.id);
        const equipped = this.data.equipped === item.id;
        const el = document.createElement('div');
        el.className = `shop-item ${equipped ? 'equipped' : ''}`;
        el.dataset.r = item.rarity;
        
        const c = document.createElement('canvas'); 
        const art = AssetFactory.get(item.id);
        const scale = art.h > 10 ? 5 : 7;
        c.width=90; c.height=90; 
        
        const ctx = c.getContext('2d'); 
        ctx.imageSmoothingEnabled = false;
        
        const drawW = art.w * scale;
        const drawH = art.h * scale;
        ctx.drawImage(art.img, (90-drawW)/2, (90-drawH)/2, drawW, drawH);

        el.innerHTML = `<div class="item-preview"></div><div class="item-name">${item.name}</div><div class="item-price">${owned ? (equipped?'EQUIPPED':'OWNED') : item.price+' Stars'}</div><div class="item-desc">${item.desc || ''}</div>`;
        el.firstChild.appendChild(c);
        
        el.onclick = () => {
           if(owned) {
             this.data.equipped = (this.data.equipped === item.id) ? null : item.id;
             StorageManager.save(this.data);
           } else if(this.data.totalStars >= item.price) {
             this.data.totalStars -= item.price;
             this.data.unlocked.push(item.id);
             this.data.equipped = item.id;
             StorageManager.save(this.data);
           } else {
             const p = el.querySelector('.item-price');
             const old = p.innerText; p.innerText = "NEED MORE STARS!"; p.style.color="#f00";
             setTimeout(()=>{ p.innerText=old; p.style.color="#ffd700"; }, 1000);
           }
           this.updateShop();
        };
        this.ui.shopGrid.appendChild(el);
      });
    }

    /* --- CRACK MODE LOGIC --- */
    checkCrackTrigger(prevP, currP) {
        if (prevP > 0.9 && currP < 0.1 && !this.crackMode) {
            this.startCrackSequence();
        }
    }

    startCrackSequence() {
        this.dialogOpen = true; 
        this.crackDenials = 0;
        this.ui.winPopup.style.display = "flex";
    }

    denyCrackMode() {
        this.crackDenials++;
        if (this.crackDenials >= 3) {
            this.ui.winPopup.style.display = "none";
            this.dialogOpen = false; 
        } else {
            this.ui.winPopup.style.display = "none";
            setTimeout(() => {
                this.ui.winPopup.style.left = (50 + Utils.rand(-10,10)) + "%";
                this.ui.winPopup.style.top = (50 + Utils.rand(-10,10)) + "%";
                this.ui.winPopup.style.display = "flex";
            }, 100);
        }
    }

    enableCrackMode() {
        this.ui.winPopup.style.display = "none";
        this.ui.crackLoad.style.display = "flex";
        this.ui.loadFill.style.width = "0%";
        setTimeout(() => { this.ui.loadFill.style.width = "40%"; }, 500);
        setTimeout(() => { this.ui.loadFill.style.width = "80%"; }, 1200);
        setTimeout(() => { 
            this.ui.loadFill.style.width = "100%";
            setTimeout(() => {
                this.ui.crackLoad.style.display = "none";
                this.startCutscene();
            }, 500);
        }, 2000);
    }

    startCutscene() {
        this.inCutscene = true;
        this.cutsceneTime = 0;
        this.dialogOpen = false;
    }

    activateFPSMode() {
        this.inCutscene = false;
        this.crackMode = true;
        // Hide 2D UI
        document.getElementById("hud-container").style.display = "none";
        document.getElementById("overlay-center").style.display = "none";
        this.ui.fpsHud.style.display = "block";
        
        // Init FPS Engine
        this.fpsEngine = new RaycasterEngine(this.cvs);
    }

    resize() {
      this.dpr = window.devicePixelRatio || 1;
      this.cvs.width = window.innerWidth * this.dpr;
      this.cvs.height = window.innerHeight * this.dpr;
      this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
      this.ctx.imageSmoothingEnabled = false;
      this.w = this.cvs.width / this.dpr;
      this.h = this.cvs.height / this.dpr;
      if(this.player) this.player.y = Math.min(this.player.y, this.groundY - 50);
    }

    get groundY() { return this.h - CONSTANTS.DIMS.GROUND_OFF; }

    reset() {
      this.player = new Player(this.groundY);
      this.speed = CONSTANTS.PHYSICS.SPEED_START;
      this.score = 0;
      this.runStars = 0;
      this.startDelay = true;
      this.time = 0;
      this.pauseTime = 20.0;
      this.isPaused = false;
      this.lastT = performance.now();

      this.worldTheme = 'normal';
      this.hellWorldActive = false;
      this.hellResurrectionUsed = false;
      this.spaceJourneyActive = false;
      this.weather.rain = [];
      this.weather.rainTimer = 0;
      this.passiveFloaters = [];
      this.discoPulse = 0;
      this.midasPassiveTimer = 0;
      this.magusShield = 0;
      this.magusCooldown = 0;
      this.magusFlash = 0;
      this.magusSigils = [];
      this.cowCooldown = 0;
      this.overlayMessageTime = 0;

      this.buildWorldGeometry();

      this.ui.score.innerText = "0";
      this.ui.stars.innerText = this.data.totalStars;
      this.ui.highScore.innerText = this.data.highScore;
      this.ui.overlay.innerText = "Tap / Space to Start";
      this.ui.overlay.style.opacity = 1;
      this.ui.death.style.opacity = 0;
      this.ui.death.className = "";
      this.ui.death.style.pointerEvents = "none";
      this.ui.shopBtn.style.display = "block";
      this.ui.mult.className = "";
      this.ui.multTime.innerText = "";
      this.ui.multTxt.innerText = "";
      this.ui.pause.style.display = "none";

      this.initWorld();
    }

    buildWorldGeometry() {
      this.objs = { plats: [], stars: [], mults: [], parts: [], birds: [], clouds: [], cows: [], mtn: { f:[], n:[], h:[] } };
      this.activeMult = { val: 1, time: 0 };
      this.bgStars = [];
      for(let i=0; i<35; i++) this.bgStars.push({x:Math.random(), y:Math.random(), s:Math.random()*2+1, a:Math.random()});
      this.shootStar = null;
      this.currentCycle = this.cycle.get(this.score || 0);
      this.orbit = this.computeCelestialState(this.currentCycle.p);
    }

    initWorld() {
      const H = this.h;
      const layer = (arr, w, min, max, s, type) => {
        let x = 0, y = Utils.rand(min, max);
        while(x < this.w + w) {
          let segs = (type === 'far') ? 8 : 4;
          let segW = w / segs;
          let pts = [{x:0,y}];
          let cy = y;
          for(let i=1; i<=segs; i++) {
            cy = Utils.clamp(cy + Utils.rand(type==='hills'?-50:-100, type==='hills'?50:100), min, max);
            if(type === 'near') cy = Utils.clamp(cy + Utils.rand(-40,40), min, max); 
            pts.push({x:i*segW, y:cy});
          }
          let snowNoise = [];
          if(type === 'far') {
              const noiseSteps = Math.ceil(w / 10);
              for(let k=0; k<=noiseSteps; k++) snowNoise.push(Utils.rand(-5, 5));
          }
          arr.push({x, w, pts, s, snowNoise});
          x += w; y = cy;
        }
      };
      layer(this.objs.mtn.f, 800, H-650, H-400, 0.15, 'far');
      layer(this.objs.mtn.n, 700, H-450, H-250, 0.3, 'near');
      layer(this.objs.mtn.h, 450, H-180, H-100, 0.6, 'hills');
      
      for(let i=0; i<6; i++) {
          let cx = Utils.rand(0, this.w);
          let parts = [];
          parts.push({x:0, y:0, w:80, h:40});
          parts.push({x:-20, y:10, w:40, h:30});
          parts.push({x:60, y:10, w:40, h:30});
          parts.push({x:10, y:-15, w:50, h:30});
          this.objs.clouds.push({x:cx, y:Utils.rand(20,H*0.4), parts, s:Utils.rand(10,25), a:Utils.rand(0.6,0.9)});
      }
      for(let i=0; i<3; i++) this.spawnBird();
      
      let cx = this.player.x - 60;
      this.objs.plats.push({x:cx, y:this.groundY, w:500, h:CONSTANTS.DIMS.PLAT_H});
      cx += 560;
      for(let i=0; i<6; i++) cx = this.addPlatform(cx, i);
    }

    checkOverlap(x, y, margin=40) {
        for(let s of this.objs.stars) {
            if(Math.abs(s.x - x) < margin && Math.abs(s.y - y) < margin) return true;
        }
        for(let m of this.objs.mults) {
            if(Math.abs(m.x - x) < margin && Math.abs(m.y - y) < margin) return true;
        }
        return false;
    }

    addPlatform(sx, idx) {
      const gap = Utils.rand(CONSTANTS.GEN.GAP.MIN, CONSTANTS.GEN.GAP.MAX);
      const w = Utils.rand(CONSTANTS.GEN.WIDTH.MIN, CONSTANTS.GEN.WIDTH.MAX);
      const ly = this.objs.plats.length ? this.objs.plats[this.objs.plats.length-1].y : this.groundY;
      const y = Utils.clamp(ly + Utils.rand(CONSTANTS.GEN.Y_VAR.MIN, CONSTANTS.GEN.Y_VAR.MAX), 70, this.h - 80);
      const p = { x: sx + gap, y, w, h: CONSTANTS.DIMS.PLAT_H };
      this.objs.plats.push(p);

      const tryMult = (this.activeMult.time <= 0) && (Math.random() < CONSTANTS.GEN.MULT_C);
      
      if (tryMult) {
        const r = Math.random(), val = r<0.1 ? 5 : (r<0.3 ? 3 : 2);
        const mx = p.x + p.w/2, my = p.y-25;
        if (!this.checkOverlap(mx, my)) {
            this.objs.mults.push({ x: mx, y: my, val, dur: Utils.rand(5,10) });
        }
      } else if (this.activeMult.time > 0) {
        const count = this.activeMult.val, spac = CONSTANTS.DIMS.STAR*2, tw = count*spac;
        if (p.w - tw > 0) {
          const start = p.x + Utils.rand(20, p.w - tw - 20);
          for(let i=0; i<count; i++) {
              const sx = start + i*spac + CONSTANTS.DIMS.STAR/2, sy = p.y - 22;
              if(!this.checkOverlap(sx, sy)) this.spawnStar(sx, sy);
          }
        }
      }

      if (!tryMult && Math.random() < CONSTANTS.GEN.STAR_C) {
        const sx = p.x + p.w/2, sy = p.y - 22;
        if(!this.checkOverlap(sx, sy)) this.spawnStar(sx, sy);
      }

      if (idx > 0 && Math.random() < CONSTANTS.GEN.GAP_STAR_C) {
        let prev = this.objs.plats[this.objs.plats.length-2];
        const sx = prev.x + prev.w + gap/2;
        const sy = Utils.clamp((prev.y+p.y)/2 - 80, this.h*0.1, this.h-200);
        if(!this.checkOverlap(sx, sy)) this.spawnStar(sx, sy);
      }
      return p.x + p.w;
    }

    spawnStar(x, y) { 
        this.objs.stars.push({ x, y, s:CONSTANTS.DIMS.STAR, r:Utils.rand(0,6), col:false, anim:0, val: this.activeMult.time > 0 ? this.activeMult.val : 1 }); 
    }
    
    spawnBird() {
      const rare = Math.random()<0.05, pool = rare ? CONSTANTS.COLORS.BIRDS_R : CONSTANTS.COLORS.BIRDS_C;
      this.objs.birds.push({ x:this.w+Utils.rand(50,350), y:Utils.rand(this.h*0.35,this.h*0.55), s:Utils.rand(90,140), flap:0, c:pool[Math.floor(Math.random()*pool.length)] });
    }

    onPlayerLand(platform) {
      if (this.isHatActive('king')) {
        this.markMidasPlatform(platform);
      }
      
      // Disco particles when landing with disco hat
      if (this.isHatActive('afro') && Math.random() < 0.6) {
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const speed = Math.random() * 120 + 80;
          const hue = Math.random() * 360;
          this.objs.parts.push({
            x: this.player.x + this.player.size/2,
            y: this.player.y + this.player.size,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 100,
            l: 0.4,
            c: `hsla(${hue},100%,60%,0.8)`
          });
        }
      }
    }

    markMidasPlatform(platform) {
      platform.midas = true;
      platform.midasPulse = 1;
    }

    grantRunStars(amount, source='star') {
      const gain = Math.max(0, Math.floor(amount));
      if(!gain) return;
      this.runStars += gain;
      this.ui.stars.innerText = this.data.totalStars + this.runStars;
      if(source === 'midas-passive') {
        this.passiveFloaters.push({
          x: this.player.x + this.player.size/2,
          y: this.player.y - 10,
          life: 1,
          text: `+${gain}`
        });
      }
    }

    finalizeRunTotals() {
      this.data.totalStars += this.runStars;
      const roundedScore = Math.floor(this.score);
      if (roundedScore > this.data.highScore) {
        this.data.highScore = roundedScore;
      }
      StorageManager.save(this.data);
      this.ui.stars.innerText = this.data.totalStars;
      this.ui.highScore.innerText = this.data.highScore;
    }

    determineWorldTheme() {
      if (this.hellWorldActive) return 'hell';
      if (this.spaceJourneyActive) return 'moon';
      if (this.isHatActive('fedora')) return 'noir';
      if (this.isHatActive('afro')) return 'disco';
      if (this.isHatActive('spartan')) return 'spartan';
      return 'normal';
    }

    handleHatPassives(dt) {
      this.worldTheme = this.determineWorldTheme();
      if (this.isHatActive('wizardMega')) {
        this.player.maxJumps = 3;
        this.prevMagusCooldown = this.magusCooldown;
        this.magusCooldown = Math.max(0, this.magusCooldown - dt);
        
        // Spawn particles when cooldown completes
        if (this.prevMagusCooldown > 0 && this.magusCooldown <= 0) {
          const centerX = this.player.x + this.player.size/2;
          const centerY = this.player.y - 45;
          for (let i = 0; i < 20; i++) {
            const angle = (i / 20) * Math.PI * 2;
            const speed = 180;
            this.objs.parts.push({
              x: centerX,
              y: centerY,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              l: 0.6,
              c: "#e9d4ff"
            });
          }
        }
      } else {
        this.player.maxJumps = 2;
        this.magusCooldown = Math.max(0, this.magusCooldown - dt);
      }
      this.player.jumps = Math.min(this.player.jumps, this.player.maxJumps);

      if (this.isHatActive('king')) {
        this.midasPassiveTimer += dt;
        if (this.midasPassiveTimer >= MIDAS_CONFIG.passiveRate) {
          this.midasPassiveTimer -= MIDAS_CONFIG.passiveRate;
          this.grantRunStars(MIDAS_CONFIG.passiveAmount, 'midas-passive');
        }
      } else {
        this.midasPassiveTimer = 0;
      }

      if (this.isHatActive('fedora')) {
        this.weather.rainTimer += dt;
        if (this.weather.rainTimer >= 0.05) {
          this.weather.rainTimer = 0;
          this.weather.rain.push({
            x: Utils.rand(-50, this.w + 50),
            y: Utils.rand(-40, 0),
            vy: Utils.rand(420, 620)
          });
          if (this.weather.rain.length > 160) this.weather.rain.shift();
        }
      } else if (this.weather.rain.length) {
        this.weather.rain = [];
        this.weather.rainTimer = 0;
      }
      this.weather.rain.forEach(drop => {
        drop.x -= this.speed * 0.02 * dt;
        drop.y += drop.vy * dt;
      });
      this.weather.rain = this.weather.rain.filter(drop => drop.y < this.h + 40);

      this.magusFlash = Math.max(0, this.magusFlash - dt);
      this.magusSigils.forEach(s => {
        s.life -= dt;
        s.rotation = (s.rotation || 0) + dt * 2;
      });
      this.magusSigils = this.magusSigils.filter(s => s.life > 0);

      if (this.isHatActive('afro') && this.orbit?.moon?.visible) {
        this.discoPulse += dt * 2;
      } else {
        this.discoPulse = Math.max(0, this.discoPulse - dt);
      }

      if (this.isHatActive('astro') && this.orbit?.moon?.visible && !this.spaceJourneyActive) {
        this.cowCooldown -= dt;
        if (this.cowCooldown <= 0) {
          this.spawnSpaceCow();
          this.cowCooldown = Utils.rand(6, 12);
        }
      } else {
        this.objs.cows = [];
        this.cowCooldown = Utils.rand(4, 8);
      }

      if (this.worldTheme === 'hell' && Math.random() < 0.3) {
        this.objs.parts.push({
          x: Utils.rand(0, this.w),
          y: this.h - Utils.rand(40, 200),
          vx: Utils.rand(-30, 30),
          vy: Utils.rand(-160, -60),
          l: Utils.rand(0.3, 0.6),
          c: "#ff7b00"
        });
      }

      if (this.worldTheme === 'moon' && Math.random() < 0.2) {
        this.objs.parts.push({
          x: Utils.rand(0, this.w),
          y: Utils.rand(0, this.h * 0.4),
          vx: Utils.rand(-20, 20),
          vy: Utils.rand(-20, -5),
          l: Utils.rand(0.4, 0.8),
          c: "#bde0fe"
        });
      }

      if (this.worldTheme === 'spartan' && Math.random() < 0.25) {
        this.objs.parts.push({
          x: Utils.rand(0, this.w),
          y: Utils.rand(this.h*0.2, this.h*0.8),
          vx: Utils.rand(-10, 10),
          vy: Utils.rand(-50, -5),
          l: Utils.rand(0.2, 0.5),
          c: "#ffd29c"
        });
      }

      if (this.worldTheme === 'disco' && Math.random() < 0.35) {
        this.objs.parts.push({
          x: Utils.rand(0, this.w),
          y: Utils.rand(0, this.h*0.5),
          vx: 0,
          vy: Utils.rand(15, 40),
          l: Utils.rand(0.3, 0.6),
          c: `hsla(${Utils.randInt(200,320)},80%,70%,0.6)`
        });
      }

      this.updateSpaceCows(dt);
      this.updatePassiveFloaters(dt);
      this.magusShield = Math.max(0, this.magusShield - dt);
    }

    spawnSpaceCow() {
      if(!this.objs.cows) this.objs.cows = [];
      const cow = {
        x: Utils.rand(80, this.w - 80),
        y: this.h + 60,
        vx: Utils.rand(-40, 40),
        vy: -Utils.rand(210, 260),
        w: 34,
        h: 26,
        active: true
      };
      this.objs.cows.push(cow);
    }

    updateSpaceCows(dt) {
      if(!this.objs.cows) return;
      const pBox = {x:this.player.x, y:this.player.y, w:this.player.size, h:this.player.size};
      this.objs.cows.forEach(cow => {
        cow.x += cow.vx * dt;
        cow.y += cow.vy * dt;
        cow.vy -= 20 * dt;
        if(!cow.active) return;
        if (Utils.AABB(pBox, {x:cow.x-15, y:cow.y-15, w:cow.w, h:cow.h})) {
          cow.active = false;
          this.enterMoonWorld();
        }
      });
      this.objs.cows = this.objs.cows.filter(cow => cow.y > -80 && cow.active !== false);
    }

    updatePassiveFloaters(dt) {
      this.passiveFloaters.forEach(f => {
        f.y -= 40 * dt;
        f.life -= dt;
      });
      this.passiveFloaters = this.passiveFloaters.filter(f => f.life > 0);
    }

    triggerMagusSave() {
      this.player.alive = true;
      this.player.vy = -1200;
      this.player.y = Math.max(80, this.groundY - this.player.size - 60);
      this.player.jumps = this.player.maxJumps;
      this.magusCooldown = this.magusCooldownMax;
      this.magusShield = 1.6;
      this.magusFlash = 1.2;
      this.showOverlayMessage("The Grand Magus rewinds fate", 1.6);
      const centerX = this.player.x + this.player.size/2;
      const centerY = this.player.y + this.player.size/2;
      this.magusSigils.push({
        x: centerX,
        y: centerY,
        radius: 70,
        life: 1.6,
        rotation: 0
      });
      for(let i=0; i<80; i++) {
        const angle = (i/80) * Math.PI * 2;
        const speed = Utils.rand(280, 460);
        this.objs.parts.push({
          x: centerX,
          y: centerY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          l: 1.4,
          c: i % 3 === 0 ? "#ffd700" : "#a876ff"
        });
      }
    }

    enterHellWorld() {
      if (this.hellWorldActive) return;
      this.hellWorldActive = true;
      this.hellResurrectionUsed = true;
      this.worldTheme = 'hell';
      this.player.alive = true;
      this.player.y = this.groundY - this.player.size - 20;
      this.player.vy = -900;
      this.player.jumps = this.player.maxJumps;
      this.ui.death.style.opacity = 0;
      this.ui.death.style.pointerEvents = "none";
      this.ui.death.className = "";
      this.ui.shopBtn.style.display = "none";
      this.ui.mult.className = "";
      this.ui.multTime.innerText = "";
      this.startDelay = false;
      this.buildWorldGeometry();
      this.initWorld();
      this.objs.cows = [];
      this.showOverlayMessage("You fall into the underworld.", 2.2);
      for(let i=0; i<80; i++) {
        this.objs.parts.push({
          x: this.player.x + this.player.size/2,
          y: this.player.y + this.player.size,
          vx: Utils.rand(-80, 80),
          vy: Utils.rand(-20, -260),
          l: Utils.rand(0.4, 0.9),
          c: i%2===0 ? "#ff5f1f" : "#ffc857"
        });
      }
    }

    enterMoonWorld() {
      if (this.spaceJourneyActive) return;
      this.spaceJourneyActive = true;
      this.worldTheme = 'moon';
      this.buildWorldGeometry();
      this.initWorld();
      this.objs.cows = [];
      this.player.y = this.groundY - this.player.size - 10;
      this.player.vy = -600;
      this.player.jumps = this.player.maxJumps;
      this.ui.mult.className = "";
      this.ui.multTime.innerText = "";
      this.ui.multTxt.innerText = "";
      this.showOverlayMessage("Low gravity unlocked.", 2);
      for(let i=0; i<60; i++) {
        this.objs.parts.push({
          x: this.player.x + this.player.size/2,
          y: this.player.y,
          vx: Utils.rand(-100, 100),
          vy: Utils.rand(-200, -40),
          l: Utils.rand(0.4, 0.8),
          c: "#c2f6ff"
        });
      }
    }

    update(dt) {
      if(!this.player.alive) return;
      
      const prevCycle = this.currentCycle || this.cycle.get(this.score);
      const prevP = prevCycle.p;
      
      if (!this.startDelay) {
        this.speed = Math.min(CONSTANTS.PHYSICS.SPEED_MAX, this.speed + dt * CONSTANTS.PHYSICS.SPEED_INC);
        this.score += (this.speed * dt) * CONSTANTS.PHYSICS.SCORE_MULT;
        this.ui.score.innerText = Math.floor(this.score);
        this.ui.highScore.innerText = Math.max(this.data.highScore, Math.floor(this.score));
      }
      
      this.currentCycle = this.cycle.get(this.score);
      const currP = this.currentCycle.p;
      this.orbit = this.computeCelestialState(currP);
      this.checkCrackTrigger(prevP, currP);
      
      // Midas death: day cycle ends with Midas Crown equipped
      if (prevP < 1.0 && currP >= 1.0 && this.isHatActive('king')) {
        this.dieMidas();
        return;
      }

      const col = this.currentCycle; 
      this.handleHatPassives(dt);

      // Rare Shooting Stars
      if(!this.shootStar && col.p > 0.55 && col.p < 0.9 && Math.random() < 0.005) {
          this.shootStar = { x:Utils.rand(0,this.w), y:Utils.rand(0,this.h/3), vx:Utils.rand(400,800), vy:Utils.rand(100,200), l:1.5 };
      }
      if(this.shootStar) {
          this.shootStar.x += this.shootStar.vx*dt;
          this.shootStar.y += this.shootStar.vy*dt;
          this.shootStar.l -= dt;
          if(this.shootStar.l <= 0) this.shootStar = null;
      }

      // Grand Magus Particles
      if (this.isHatActive('wizardMega')) {
         if (Math.random() < 0.4) {
             const angle = Math.random() * Math.PI * 2;
             const radius = Math.random() * 30;
             this.objs.parts.push({
                 x: this.player.x + this.player.size/2 + Math.cos(angle)*radius,
                 y: this.player.y + this.player.size/2 + Math.sin(angle)*radius,
                 vx: Math.cos(angle) * 60,
                 vy: Math.sin(angle) * 60,
                 l: 0.6,
                 c: Math.random() > 0.5 ? "#ffd700" : "#a876ff"
             });
         }
      }

      if(this.activeMult.time > 0) {
        this.activeMult.time -= dt;
        if(this.activeMult.time <= 0) {
           this.activeMult.val = 1;
           this.ui.mult.className = "";
           this.ui.multTime.innerText = "";
           this.objs.stars.forEach(s => s.val = 1);
        }
      }

      const scroll = this.startDelay ? 0 : this.speed * dt;

      const updL = (list, spd, min, max, type) => {
        for(let m of list) m.x -= this.speed * m.s * dt;
        list = list.filter(m => m.x + m.w > 0);
        const last = list[list.length-1];
        if(last.x + last.w < this.w + 800*0.25) {
           let segs = (type === 'far') ? 8 : 4;
           let y = last.pts[last.pts.length-1].y;
           let segW = last.w / segs;
           let pts = [{x:0,y}];
           let cy = y;
           for(let i=1; i<=segs; i++){
             cy = Utils.clamp(cy + Utils.rand(type==='hills'?-50:-100, type==='hills'?50:100), min, max);
             if(type==='near') cy = Utils.clamp(cy + Utils.rand(-40,40), min, max);
             pts.push({x:i*segW, y:cy});
           }
           let snowNoise = [];
           if(type === 'far') {
             const noiseSteps = Math.ceil(last.w / 10);
             for(let k=0; k<=noiseSteps; k++) snowNoise.push(Utils.rand(-5, 5));
           }
           list.push({x:last.x+last.w-4, w:last.w, pts, s:spd, snowNoise});
        }
        return list;
      };
      this.objs.mtn.f = updL(this.objs.mtn.f, 0.15, this.h-650, this.h-400, 'far');
      this.objs.mtn.n = updL(this.objs.mtn.n, 0.3, this.h-450, this.h-250, 'near');
      this.objs.mtn.h = updL(this.objs.mtn.h, 0.6, this.h-180, this.h-100, 'hills');

      this.objs.clouds.forEach(c => { c.x -= (this.startDelay?0:this.speed*0.12 + c.s*0.02)*dt; if(c.x+200<-100) c.x=this.w+100; });
      this.objs.birds.forEach(b => { b.x -= b.s*dt; b.flap += dt * 5; });
      this.objs.birds = this.objs.birds.filter(b => b.x > -200);
      if(this.objs.birds.length < 4) this.spawnBird();

      this.objs.plats.forEach(p => p.x -= scroll);
      this.objs.plats = this.objs.plats.filter(p => p.x + p.w > -300);
      let right = -999; this.objs.plats.forEach(p => right = Math.max(right, p.x+p.w));
      while(right < this.w + 600) right = this.addPlatform(right, this.objs.plats.length);

      const pBox = {x:this.player.x, y:this.player.y, w:this.player.size, h:this.player.size};

      this.objs.mults.forEach(m => {
        m.x -= scroll;
        if(!m.col && Utils.AABB(pBox, {x:m.x-14,y:m.y-14,w:28,h:28})) {
          m.col = true;
          this.activeMult = { val:m.val, time:m.dur };
          this.ui.multTxt.innerText = `X${m.val} STAR BONUS!`;
          this.ui.multTime.innerText = ""; // Cleared
          this.ui.mult.className = "active";
          this.objs.mults.forEach(o => o.col = true);
          
          const extras = this.activeMult.val - 1;
          const visibleStars = [...this.objs.stars];
          visibleStars.forEach(s => {
              if(s.col) return;
              for(let i=1; i<=extras; i++) {
                  const offset = (Math.ceil(i/2) * 30) * (i%2===0 ? 1 : -1);
                  this.spawnStar(s.x + offset, s.y);
              }
          });
        }
      });
      this.objs.mults = this.objs.mults.filter(m => m.x > -100 && !m.col);

      this.objs.stars.forEach(s => {
        s.x -= scroll;
        if(s.col) {
          s.anim += dt;
          s.y -= (600*dt) - (600 * s.anim * dt); 
          s.r += dt*20;
        } else {
          s.r += dt*3;
          if(Utils.AABB(pBox, {x:s.x-s.s/2,y:s.y-s.s/2,w:s.s,h:s.s})) {
            const gain = this.isHatActive('king') ? Math.ceil(s.val * MIDAS_CONFIG.starBonus) : s.val;
            this.grantRunStars(gain, this.isHatActive('king') ? 'star' : 'star');
            s.col = true;
            for(let i=0; i<8; i++) this.objs.parts.push({x:s.x, y:s.y, vx:Utils.rand(-150,150), vy:Utils.rand(-250,-50), l:0.6, c:CONSTANTS.COLORS.STAR});
          }
        }
      });
      this.objs.stars = this.objs.stars.filter(s => s.anim < 0.6);

      this.objs.parts.forEach(p => { p.x+=p.vx*dt; p.y+=p.vy*dt; p.l-=dt; });
      this.objs.parts = this.objs.parts.filter(p => p.l > 0);

      if(!this.startDelay) this.player.update(dt, this.objs.plats, CONSTANTS.PHYSICS.GRAVITY, (p) => this.onPlayerLand(p));
      
      // Continuous disco particles while moving on platform with disco hat
      if (this.isHatActive('afro') && this.player.vy === 0 && Math.abs(this.player.vx || 0) > 20 && Math.random() < 0.4) {
        const hue = Math.random() * 360;
        this.objs.parts.push({
          x: this.player.x + this.player.size/2 + Math.random()*10 - 5,
          y: this.player.y + this.player.size,
          vx: (Math.random() - 0.5) * 60,
          vy: -Math.random() * 200 - 50,
          l: 0.35,
          c: `hsla(${hue},100%,60%,0.7)`
        });
      }
      
      if(this.overlayMessageTime > 0 && !this.startDelay) {
        this.overlayMessageTime -= dt;
        if(this.overlayMessageTime <= 0) {
          this.ui.overlay.style.opacity = 0;
        }
      }
      
      if(this.player.y > this.h + CONSTANTS.DIMS.DEATH_Z) {
        this.die();
      }
    }

    drawClock(p) {
        const ctx = this.clockCtx;
        const w = 64, h = 64;
        ctx.clearRect(0,0,w,h);
        const cx = w/2, cy = h/2;
        
        const grad = ctx.createLinearGradient(0,0,w,h);
        grad.addColorStop(0, "#DAA520"); grad.addColorStop(1, "#8B4513");
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(cx, cy, 30, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#1a1a2e"; 
        ctx.beginPath(); ctx.arc(cx, cy, 26, 0, Math.PI*2); ctx.fill();

        ctx.save();
        ctx.translate(cx, cy);
        const angle = p * Math.PI * 2;
        ctx.rotate(angle);
        
        ctx.fillStyle = "rgba(135, 206, 235, 0.3)";
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,26, -Math.PI/2, Math.PI/2); ctx.fill();
        
        ctx.fillStyle = "#FFD700";
        ctx.beginPath(); ctx.arc(0, -18, 4, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#FFA500"; ctx.lineWidth=1; ctx.stroke();
        
        ctx.fillStyle = "#FFF";
        ctx.beginPath(); ctx.arc(0, 18, 3, 0, Math.PI*2); ctx.fill();
        
        ctx.restore();

        const glass = ctx.createLinearGradient(0,0,w,h);
        glass.addColorStop(0, "rgba(255,255,255,0.4)"); glass.addColorStop(0.5, "rgba(255,255,255,0)");
        ctx.fillStyle = glass;
        ctx.beginPath(); ctx.arc(cx, cy, 26, 0, Math.PI*2); ctx.fill();
    }

    computeCelestialState(p) {
      const cx = this.w / 2;
      const cy = this.h + 100; 
      const radius = this.w / 2 + 150;
      const angle = (p * 2 * Math.PI) - Math.PI/2;
      const sun = { x: cx + Math.cos(angle) * radius, y: cy + Math.sin(angle) * radius };
      const moon = { x: cx + Math.cos(angle + Math.PI) * radius, y: cy + Math.sin(angle + Math.PI) * radius };
      sun.visible = sun.y < this.h + 200;
      moon.visible = moon.y < this.h + 200;
      return { sun, moon };
    }

    getWorldColors(col) {
      const theme = WORLD_THEMES[this.worldTheme] || WORLD_THEMES.normal;
      const basePlat = WORLD_THEMES.normal.platform;
      const colors = {
        skyTop: theme.skyTop || col.skyTop,
        skyBot: theme.skyBot || col.skyBot,
        far: theme.far || col.far,
        near: theme.near || col.near,
        hills: theme.hills || col.hills,
        platform: {
          body: (theme.platform && theme.platform.body) || basePlat.body,
          top: (theme.platform && theme.platform.top) || basePlat.top
        },
        star: theme.star || WORLD_THEMES.normal.star,
        player: theme.player || WORLD_THEMES.normal.player
      };
      if (this.isHatActive('spartan')) {
        const tint = "#c97b37";
        colors.skyTop = Utils.lerpColor(colors.skyTop, tint, 0.4);
        colors.skyBot = Utils.lerpColor(colors.skyBot, "#5f2003", 0.4);
        colors.far = Utils.lerpColor(colors.far, "#5f3715", 0.5);
        colors.near = Utils.lerpColor(colors.near, "#8f4a10", 0.5);
        colors.hills = Utils.lerpColor(colors.hills, "#b35c1f", 0.5);
      }
      if (this.isHatActive('fedora')) {
        const gray = (hex) => Utils.toGray(hex);
        colors.skyTop = gray(colors.skyTop);
        colors.skyBot = gray(colors.skyBot);
        colors.far = gray(colors.far);
        colors.near = gray(colors.near);
        colors.hills = gray(colors.hills);
        colors.platform.body = gray(colors.platform.body);
        colors.platform.top = gray(colors.platform.top);
        colors.star = gray(colors.star);
      }
      return colors;
    }

    drawCelestialBodies(col, colors) {
      const ctx = this.ctx;
      const orbit = this.orbit || this.computeCelestialState(col.p);
      const drawBody = (body, color, glow, radius, isSun) => {
        if(!body.visible) return;
        const horizonDist = (this.h + 200) - body.y;
        const alpha = Math.min(1, horizonDist / 200);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.shadowBlur = isSun ? 40 : 20;
        ctx.shadowColor = glow;
        ctx.beginPath();
        ctx.arc(body.x, body.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        if(isSun) {
          ctx.fillStyle = "#ffffe0";
          ctx.beginPath(); ctx.arc(body.x, body.y, radius - 10, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
      };

      drawBody(orbit.sun, "#FFD700", "orange", 40, true);

      ctx.save();
      const moonRadius = 35;
      if (orbit.moon.visible) {
        if (this.isHatActive('afro')) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(orbit.moon.x, orbit.moon.y, moonRadius, 0, Math.PI*2);
          ctx.clip();
          const step = 6;
          for(let y=-moonRadius; y<moonRadius; y+=step) {
            for(let x=-moonRadius; x<moonRadius; x+=step) {
              const hue = (this.discoPulse * 120 + (x*3) + (y*5)) % 360;
              ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.85)`;
              ctx.fillRect(orbit.moon.x + x, orbit.moon.y + y, step-1, step-1);
            }
          }
          ctx.restore();

          const rayCount = 8;
          for(let i=0; i<rayCount; i++) {
            const ang = this.discoPulse + i * (Math.PI * 2 / rayCount);
            ctx.fillStyle = `hsla(${(this.discoPulse*120 + i*40)%360}, 80%, 50%, 0.25)`;
            ctx.beginPath();
            ctx.moveTo(orbit.moon.x, orbit.moon.y);
            ctx.lineTo(orbit.moon.x + Math.cos(ang)*400, orbit.moon.y + Math.sin(ang)*400);
            ctx.lineTo(orbit.moon.x + Math.cos(ang + 0.12)*400, orbit.moon.y + Math.sin(ang + 0.12)*400);
            ctx.closePath();
            ctx.fill();
          }
        } else {
          drawBody(orbit.moon, "#F5F3CE", "white", moonRadius, false);
          ctx.fillStyle = "rgba(0,0,0,0.1)"; 
          ctx.beginPath(); ctx.arc(orbit.moon.x-10, orbit.moon.y-5, 8, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(orbit.moon.x+12, orbit.moon.y+10, 5, 0, Math.PI*2); ctx.fill();
        }
      }
      ctx.restore();
    }

    draw() {
      const ctx = this.ctx, W = this.w, H = this.h;
      
      // Cutscene Mode
      if (this.inCutscene) {
          ctx.fillStyle = "#000";
          ctx.fillRect(0,0,W,H);
          
          ctx.save();
          // Center on Player
          const pl = this.player;
          const cx = pl.x + pl.size/2;
          const cy = pl.y + pl.size/2;
          
          ctx.translate(W/2, H/2);
          
          // Animation Progress
          this.cutsceneTime += 0.03;
          const progress = Math.min(1, this.cutsceneTime / 4); // 4 seconds duration
          const scale = 1 + Math.pow(progress, 3) * 30; // Zoom heavily at end
          const rot = progress * Math.PI * 4; // Spin 2 times
          
          ctx.scale(scale, scale);
          ctx.rotate(rot);
          ctx.translate(-cx, -cy); // Move world so player is at center
          
          // Draw just the player surroundings for effect
          // Sky
          ctx.fillStyle = "#4b8ce6";
          ctx.fillRect(cx-W, cy-H, W*2, H*2);
          
          // Player
          ctx.fillStyle = CONSTANTS.COLORS.PLAYER; 
          ctx.fillRect(pl.x, pl.y, pl.size, pl.size);
          ctx.shadowColor = "#e6ac00"; ctx.shadowBlur = 10; 
          ctx.strokeRect(pl.x, pl.y, pl.size, pl.size); ctx.shadowBlur = 0;
          
          // Eye Entry
          if (progress >= 1) {
              this.activateFPSMode();
          }
          
          ctx.restore();
          return;
      }

      const col = this.currentCycle || this.cycle.get(this.score);
      
      this.drawClock(col.p);

      const colors = this.getWorldColors(col);
      
      // Apply Matrix effect if cyber glasses equipped
      const hasMatrixEffect = this.data.equipped === 'cyberglasses';
      let effectColors = colors;
      if (hasMatrixEffect) {
        effectColors = {
          skyTop: "#001a00",
          skyBot: "#000000",
          far: "#0d2d0d",
          near: "#1a5a1a",
          hills: "#2d7a2d",
          platform: { body: "#0d3d0d", top: "#00ff00" },
          star: "#00ff00",
          player: "#00dd00"
        };
      }

      const grad = ctx.createLinearGradient(0,0,0,H);
      grad.addColorStop(0, effectColors.skyTop); grad.addColorStop(0.5, effectColors.skyBot); grad.addColorStop(1, Utils.lerpColor(effectColors.skyBot, "#ffffff", 0.05));
      ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);

      let starAlpha = 0;
      if (col.p > 0.4 && col.p < 0.9) {
          starAlpha = 1;
          if(col.p < 0.55) starAlpha = (col.p - 0.4) * 6.6; 
          if(col.p > 0.85) starAlpha = (0.9 - col.p) * 20; 
      }

      if(starAlpha > 0) {
          ctx.fillStyle = "white";
          this.bgStars.forEach(s => {
              ctx.globalAlpha = s.a * starAlpha;
              ctx.fillRect(s.x*W, s.y*H*0.6, s.s, s.s);
          });
          ctx.globalAlpha = 1;
      }

      this.drawCelestialBodies(col, colors);
      if (this.worldTheme === 'moon') this.drawMoonBackdrop(ctx);

      if(this.shootStar && starAlpha > 0.5) {
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.globalAlpha = Math.min(1, this.shootStar.l);
          ctx.beginPath();
          ctx.moveTo(this.shootStar.x, this.shootStar.y);
          ctx.lineTo(this.shootStar.x - this.shootStar.vx*0.1, this.shootStar.y - this.shootStar.vy*0.1);
          ctx.stroke();
          ctx.globalAlpha = 1;
      }

      const allowClouds = !['noir','disco'].includes(this.worldTheme);
      if (allowClouds) {
        const ca = Utils.lerp(1, 0.2, col.p>0.5?(col.p-0.5)*2:0);
        this.objs.clouds.forEach(c => { 
          ctx.globalAlpha = c.a*ca; 
          ctx.fillStyle = "white";
          c.parts.forEach(p => ctx.fillRect(c.x+p.x, c.y+p.y, p.w, p.h));
        });
        ctx.globalAlpha = 1;
      }

      const drawMtn = (l, c, isFar) => {
        l.forEach(m => {
          const rx = Math.round(m.x);
          ctx.fillStyle = c; 
          ctx.beginPath(); 
          ctx.moveTo(rx, H);
          m.pts.forEach(pt => ctx.lineTo(rx+pt.x, pt.y));
          ctx.lineTo(rx+m.w, H);
          ctx.fill();

          if(isFar) {
             ctx.save();
             ctx.clip(); 
             
             ctx.fillStyle = "#fff";
             // Threshold ~0.35 for high peaks
             const snowThreshold = H * 0.35; 
             
             ctx.beginPath();
             ctx.moveTo(rx, 0); 
             ctx.lineTo(rx + m.w, 0); 
             
             const step = 10;
             const steps = Math.floor(m.w / step);
             for(let i = steps; i >= 0; i--) {
                 const xPos = i * step;
                 const noiseVal = m.snowNoise && m.snowNoise[i] ? m.snowNoise[i] : 0;
                 ctx.lineTo(rx + xPos, snowThreshold + noiseVal);
             }
             
             ctx.closePath();
             ctx.fill();
             ctx.restore();
          }
        });
      };
      const themedBackdrop = ['noir','disco','spartan'].includes(this.worldTheme);
      if (themedBackdrop) {
        this.drawThemedBackdrop(ctx);
      } else {
        drawMtn(this.objs.mtn.f, colors.far, true);
        drawMtn(this.objs.mtn.n, colors.near, false);
        this.objs.birds.forEach(b => {
          ctx.save(); ctx.translate(b.x, b.y);
          const frame = Math.floor(b.flap) % 2;
          const wingColor = this.isHatActive('fedora') ? Utils.toGray(b.c) : b.c;
          ctx.fillStyle=wingColor; ctx.fillRect(0,0,12,8); ctx.fillRect(12,-4,8,8);
          ctx.fillStyle="#ff9800"; ctx.fillRect(20,-4,4,4);
          ctx.fillStyle=wingColor; ctx.globalAlpha=0.85; ctx.fillRect(4, frame===0?-8:4, 8, 8);
          ctx.restore();
        });
        drawMtn(this.objs.mtn.h, colors.hills, false);
      }

      if (this.worldTheme === 'hell') {
        this.drawHellFissures(ctx);
      }

      this.drawSpaceCows(ctx);

      ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 2;
      this.objs.plats.forEach(p => {
        if (p.midas) {
          const grd = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
          grd.addColorStop(0, "#fff4c3");
          grd.addColorStop(1, "#d4af37");
          ctx.fillStyle = grd;
          ctx.fillRect(p.x, p.y, p.w, p.h);
          ctx.fillStyle = "#ffeaa7";
          ctx.fillRect(p.x, p.y, p.w, 6);
          p.midasPulse = (p.midasPulse ?? 1);
          ctx.save();
          ctx.globalAlpha = Math.max(0, p.midasPulse);
          ctx.strokeStyle = "rgba(255,244,195,0.9)";
          ctx.lineWidth = 4;
          ctx.strokeRect(p.x-2, p.y-2, p.w+4, p.h+4);
          ctx.restore();
          p.midasPulse = Math.max(0, p.midasPulse - 0.03);
        } else {
          ctx.fillStyle=effectColors.platform.body; ctx.fillRect(p.x, p.y, p.w, p.h);
          ctx.fillStyle=effectColors.platform.top; ctx.fillRect(p.x, p.y, p.w, 6);
        }
        ctx.strokeRect(p.x, p.y, p.w, p.h);
      });

      this.objs.mults.forEach(m => {
        const art = AssetFactory.get(m.val.toString());
        if(art) {
           const y = m.y + Math.sin(this.time*4)*5;
           const scale = 4;
           const dw = art.w * scale, dh = art.h * scale;
           ctx.drawImage(art.img, m.x-dw/2, y-dh/2, dw, dh); 
        }
      });

      ctx.fillStyle = effectColors.star; ctx.shadowColor = effectColors.star; ctx.lineJoin = "round"; ctx.lineWidth = 4;
      this.objs.stars.forEach(s => {
        ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.r);
        if(s.col) ctx.globalAlpha = Math.max(0, 1-(s.anim/0.5));
        ctx.shadowBlur = s.col ? 0 : 10;
        const sz = s.s + (s.col ? 0 : Math.sin(this.time*5)*2);
        ctx.beginPath();
        for(let i=0, rot=Math.PI/2*3; i<5; i++) {
          ctx.lineTo(Math.cos(rot)*sz/2, Math.sin(rot)*sz/2); rot+=Math.PI/5;
          ctx.lineTo(Math.cos(rot)*sz/4, Math.sin(rot)*sz/4); rot+=Math.PI/5;
        }
        ctx.closePath(); ctx.fill(); ctx.restore();
      });
      ctx.shadowBlur = 0; ctx.globalAlpha = 1;

      this.objs.parts.forEach(p => { ctx.fillStyle = p.c; ctx.globalAlpha = p.l/0.6; ctx.fillRect(p.x, p.y, 4, 4); });
      ctx.globalAlpha = 1;

      const pl = this.player;
      ctx.fillStyle = effectColors.player; ctx.fillRect(pl.x, pl.y, pl.size, pl.size);
      ctx.shadowColor = "#e6ac00"; ctx.shadowBlur = 10; ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 2;
      ctx.strokeRect(pl.x, pl.y, pl.size, pl.size); ctx.shadowBlur = 0;

      if (this.data.equipped) {
        const art = AssetFactory.get(this.data.equipped);
        if (art) {
          const scale = art.h > 10 ? 3 : 4;
          const cfg = HAT_OVERLAY_CONFIG[this.data.equipped] || {};
          const hatX = pl.x + pl.size/2 - (art.w*scale)/2;
          const hatY = pl.y - art.h*scale + (cfg.offsetY || 0);
          ctx.drawImage(art.img, hatX, hatY, art.w*scale, art.h*scale);
          if (HAT_OVERLAYS.has(this.data.equipped)) {
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = "rgba(0,0,0,0.35)";
            ctx.fillRect(pl.x, pl.y - 2, pl.size, 12);
            ctx.restore();
          }
        }
      }

      if (this.isHatActive('fedora')) {
        this.drawDetectiveAccessories(ctx, pl);
      }

      if (this.isHatActive('spartan')) {
        this.drawSpartanSword(ctx, pl);
      }

      this.drawMagusEffects(ctx, pl);

      this.drawPassiveFloatersDisplay(ctx);

      if (this.isHatActive('fedora')) {
        this.drawNoirOverlay(ctx);
      }

      this.drawDrizzle(ctx);

      if (this.worldTheme === 'hell') {
        this.drawHeatHaze(ctx);
      }

      if (this.worldTheme === 'moon') {
        this.drawMoonDust(ctx);
      }

      if (this.isHatActive('spartan')) {
        this.drawSpartanTint(ctx);
      }
      
      // Draw Matrix effect scanlines when cyber glasses equipped
      if (hasMatrixEffect) {
        ctx.save();
        ctx.fillStyle = "rgba(0,255,0,0.05)";
        for (let y = 0; y < this.h; y += 2) {
          ctx.fillRect(0, y, this.w, 1);
        }
        ctx.restore();
        
        // RoboCop-style target boxes for birds
        this.objs.birds.forEach((b, idx) => {
          this.drawMatrixTargetBox(ctx, b.x, b.y, 28, 20, `BIRD-${idx}`, `SPD: ${Math.floor(b.s)}m/s`);
        });
        
        // RoboCop-style target boxes for shooting stars
        if (this.shootStar) {
          const velocity = Math.sqrt(this.shootStar.vx**2 + this.shootStar.vy**2);
          this.drawMatrixTargetBox(ctx, this.shootStar.x, this.shootStar.y, 24, 24, "STAR", `VEL: ${Math.floor(velocity)}m/s`);
        }
        
        // RoboCop-style target boxes for multipliers
        this.objs.mults.forEach((m, idx) => {
          this.drawMatrixTargetBox(ctx, m.x, m.y, 26, 26, "MULT", `x${m.v}`);
        });
      }
    }
    
    drawMatrixTargetBox(ctx, x, y, w, h, label, info) {
      ctx.save();
      ctx.strokeStyle = "#00ff00";
      ctx.fillStyle = "rgba(0,255,0,0.05)";
      ctx.lineWidth = 2;
      
      // Main box - increased sizing for better visibility
      ctx.strokeRect(x - w/2, y - h/2, w, h);
      ctx.fillRect(x - w/2, y - h/2, w, h);
      
      // Corner brackets - improved visibility
      const cornerLen = 8;
      const corners = [
        [x - w/2, y - h/2], [x + w/2, y - h/2],
        [x - w/2, y + h/2], [x + w/2, y + h/2]
      ];
      
      corners.forEach(([cx, cy]) => {
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 2;
        if (cx === x - w/2) { // Left
          ctx.beginPath();
          ctx.moveTo(cx, cy - (cy === y - h/2 ? cornerLen : -cornerLen));
          ctx.lineTo(cx, cy + (cy === y - h/2 ? cornerLen : -cornerLen));
          ctx.moveTo(cx, cy);
          ctx.lineTo(cx + cornerLen, cy);
          ctx.stroke();
        } else { // Right
          ctx.beginPath();
          ctx.moveTo(cx, cy - (cy === y - h/2 ? cornerLen : -cornerLen));
          ctx.lineTo(cx, cy + (cy === y - h/2 ? cornerLen : -cornerLen));
          ctx.moveTo(cx, cy);
          ctx.lineTo(cx - cornerLen, cy);
          ctx.stroke();
        }
      });
      
      // Label and info text - improved positioning and sizing
      ctx.font = "bold 9px monospace";
      ctx.textAlign = "left";
      ctx.fillStyle = "#00ff00";
      ctx.fillText(label, x - w/2 + 4, y - h/2 - 4);
      ctx.font = "8px monospace";
      ctx.fillText(info, x - w/2 + 4, y + h/2 + 10);
      
      ctx.restore();
    }

    drawSpaceCows(ctx) {
      if(!this.objs.cows || !this.objs.cows.length) return;
      ctx.save();
      this.objs.cows.forEach(cow => {
        ctx.save();
        ctx.translate(cow.x, cow.y);
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(-14, -8, 28, 16);
        ctx.fillStyle = "#222";
        ctx.fillRect(4, -6, 10, 8);
        ctx.fillStyle = "#f47c7c";
        ctx.fillRect(-12, 4, 6, 4);
        ctx.restore();
      });
      ctx.restore();
    }

    drawDrizzle(ctx) {
      if(!this.weather.rain.length) return;
      ctx.save();
      ctx.strokeStyle = "rgba(180,200,255,0.45)";
      ctx.lineWidth = 1;
      this.weather.rain.forEach(drop => {
        ctx.beginPath();
        ctx.moveTo(drop.x, drop.y);
        ctx.lineTo(drop.x - 1.5, drop.y + 8);
        ctx.stroke();
      });
      ctx.restore();
    }

    drawPassiveFloatersDisplay(ctx) {
      if(!this.passiveFloaters.length) return;
      ctx.save();
      ctx.font = "14px 'Segoe UI', sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = "#ffd700";
      this.passiveFloaters.forEach(f => {
        ctx.globalAlpha = Math.max(0, f.life);
        ctx.fillText(f.text, f.x, f.y);
      });
      ctx.restore();
    }

    drawNoirOverlay(ctx) {
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.strokeStyle = "rgba(255,255,255,0.1)";
      for(let i=0; i<35; i++) {
        const x = Math.random()*this.w;
        const len = Math.random()* this.h*0.4;
        ctx.beginPath();
        ctx.moveTo(x, Math.random()*this.h);
        ctx.lineTo(x+1, Math.random()*this.h);
        ctx.stroke();
      }
      ctx.globalAlpha = 0.12;
      for(let i=0; i<120; i++) {
        ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.6})`;
        const size = Math.random()*1.5;
        ctx.fillRect(Math.random()*this.w, Math.random()*this.h, size, size);
      }
      ctx.restore();
    }

    drawHeatHaze(ctx) {
      ctx.save();
      const grad = ctx.createLinearGradient(0, this.h*0.5, 0, this.h);
      grad.addColorStop(0, "rgba(255,100,0,0)");
      grad.addColorStop(1, "rgba(255,80,0,0.35)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, this.h*0.5, this.w, this.h*0.5);
      ctx.restore();
    }

    drawMoonDust(ctx) {
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "#c2f6ff";
      for(let i=0; i<25; i++) {
        ctx.beginPath();
        ctx.arc(Math.random()*this.w, Math.random()*this.h*0.6, Math.random()*3+1, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    drawMoonBackdrop(ctx) {
      ctx.save();
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = "#1e88e5";
      ctx.beginPath();
      ctx.arc(this.w - 120, 140, 90, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#a5d6ff";
      ctx.beginPath();
      ctx.moveTo(this.w - 150, 110);
      ctx.bezierCurveTo(this.w - 100, 80, this.w - 40, 120, this.w - 80, 150);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(this.w - 90, 190);
      ctx.bezierCurveTo(this.w - 60, 170, this.w - 20, 210, this.w - 70, 220);
      ctx.fill();
      ctx.restore();
    }

    drawDetectiveAccessories(ctx, pl) {
      ctx.save();
      ctx.strokeStyle = "#f9f6d2";
      ctx.lineWidth = 2;
      const eyeX = pl.x + pl.size*0.7;
      const eyeY = pl.y + pl.size*0.4;
      ctx.beginPath();
      ctx.arc(eyeX, eyeY, 6, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(eyeX, eyeY + 6);
      ctx.lineTo(eyeX, eyeY + 16);
      ctx.stroke();
      ctx.fillStyle = "#5d4037";
      ctx.fillRect(pl.x + pl.size*0.2, pl.y + pl.size*0.7, 20, 4);
      ctx.fillStyle = "#3e2723";
      ctx.fillRect(pl.x + pl.size*0.2 - 4, pl.y + pl.size*0.7 - 4, 10, 10);
      ctx.restore();
    }

    drawSpartanSword(ctx, pl) {
      ctx.save();
      ctx.fillStyle = "#c0c0c0";
      ctx.fillRect(pl.x + pl.size + 6, pl.y + pl.size*0.4, 36, 6);
      ctx.fillStyle = "#8b4513";
      ctx.fillRect(pl.x + pl.size, pl.y + pl.size*0.35, 10, 16);
      ctx.restore();
    }

    drawSpartanTint(ctx) {
      ctx.save();
      const grad = ctx.createLinearGradient(0,0,0,this.h);
      grad.addColorStop(0, "rgba(255,215,160,0.06)");
      grad.addColorStop(1, "rgba(120,40,10,0.18)");
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,this.w,this.h);
      ctx.restore();
    }

    drawMagusEffects(ctx, pl) {
      if (this.magusShield > 0.01) {
        ctx.save();
        ctx.globalAlpha = Math.min(1, this.magusShield);
        ctx.strokeStyle = "rgba(168,118,255,0.8)";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(pl.x + pl.size/2, pl.y + pl.size/2, 40, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      if (this.magusSigils.length) {
        ctx.save();
        this.magusSigils.forEach(s => {
          ctx.globalAlpha = Math.max(0, s.life);
          ctx.strokeStyle = "rgba(168,118,255,0.7)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.radius * (s.life+0.2), 0, Math.PI*2);
          ctx.stroke();
          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.rotate(s.rotation || 0);
          ctx.strokeStyle = "rgba(255,215,128,0.5)";
          ctx.beginPath();
          ctx.rect(-s.radius*0.6, -s.radius*0.6, s.radius*1.2, s.radius*1.2);
          ctx.stroke();
          ctx.restore();
        });
        ctx.restore();
      }

      if (this.magusFlash > 0) {
        ctx.save();
        ctx.globalAlpha = this.magusFlash * 0.25;
        ctx.fillStyle = "#c9a3ff";
        ctx.fillRect(0,0,this.w,this.h);
        ctx.restore();
      }

      if (this.isHatActive('wizardMega')) {
        const cd = Math.max(0, this.magusCooldown);
        ctx.save();
        
        // Circular cooldown indicator
        const x = pl.x + pl.size/2;
        const y = pl.y - 45;
        const radius = 20;
        const progress = 1 - (cd / this.magusCooldownMax);
        
        // Background circle
        ctx.fillStyle = "rgba(100, 50, 150, 0.3)";
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.fill();
        
        // Progress arc
        if (progress > 0.01) {
          ctx.strokeStyle = cd <= 0.1 ? "#e9d4ff" : "#c9a3ff";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(x, y, radius, -Math.PI/2, -Math.PI/2 + (Math.PI*2*progress));
          ctx.stroke();
        }
        
        // Center text
        ctx.font = "bold 10px 'Segoe UI', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = cd <= 0.1 ? "#e9d4ff" : "#c9a3ff";
        const label = cd <= 0.1 ? "‚úì" : Math.ceil(cd);
        ctx.fillText(label, x, y);
        
        ctx.restore();
      }
    }

    drawThemedBackdrop(ctx) {
      if (this.worldTheme === 'noir') {
        this.drawNoirCity(ctx);
      } else if (this.worldTheme === 'disco') {
        this.drawDiscoBackdrop(ctx);
      } else if (this.worldTheme === 'spartan') {
        this.drawSpartanBackdrop(ctx);
      }
    }

    drawNoirCity(ctx) {
      // Generate backdrop once and cache it
      if (!this.noirBackdropCache) {
        this.noirBackdropCache = document.createElement('canvas');
        this.noirBackdropCache.width = this.w;
        this.noirBackdropCache.height = this.h;
        const cacheCtx = this.noirBackdropCache.getContext('2d');
        
        // 1940s color palette: dark browns, rust, deep purples
        cacheCtx.fillStyle = "#0f0e12";
        cacheCtx.fillRect(0, 0, this.w, this.h);
        
        // Starry sky gradient with faint stars
        const skyGrad = cacheCtx.createLinearGradient(0, 0, 0, this.h*0.5);
        skyGrad.addColorStop(0, "rgba(20,18,30,0.9)");
        skyGrad.addColorStop(1, "rgba(40,35,60,0.7)");
        cacheCtx.fillStyle = skyGrad;
        cacheCtx.fillRect(0, 0, this.w, this.h*0.6);
        
        // Scattered stars for atmosphere
        for(let i=0; i<15; i++) {
          const sx = (i*i*1234)%(this.w);
          const sy = ((i*567)%(this.h*0.5));
          cacheCtx.fillStyle = `rgba(180,160,200,${0.3+Math.sin(i)*0.3})`;
          cacheCtx.fillRect(sx, sy, 1.5, 1.5);
        }
        
        // Dark street/ground
        cacheCtx.fillStyle = "#1a1815";
        cacheCtx.fillRect(0, this.h*0.6, this.w, this.h*0.4);
        
        // Use seeded random for consistent building layout
        let seed = 12345;
        const seededRand = (min, max) => {
          seed = (seed * 9301 + 49297) % 233280;
          return min + (seed / 233280) * (max - min);
        };
        
        // Buildings with rust/brown tones
        for(let i=0; i<22; i++) {
          const w = seededRand(40, 90);
          const h = seededRand(this.h*0.2, this.h*0.45);
          const x = i * (this.w/20) + seededRand(-20, 20);
          const y = this.h*0.6 - h;
          
          // Rust and brown building colors
          const colors = ["rgba(80,50,40,0.8)", "rgba(70,45,35,0.85)", "rgba(90,55,45,0.8)"];
          cacheCtx.fillStyle = colors[i%3];
          cacheCtx.fillRect(x, y, w, h);
          
          // Building outlines for definition
          cacheCtx.strokeStyle = "rgba(50,30,20,0.6)";
          cacheCtx.lineWidth = 1;
          cacheCtx.strokeRect(x, y, w, h);
          
          // Windows with occasional neon glow
          for(let wy=y+10; wy<y+h; wy+=12) {
            for(let wx=x+6; wx<x+w-6; wx+=10) {
              if(seededRand(0, 1) < 0.35) {
                // Warm window light (1940s apartment glow)
                cacheCtx.fillStyle = "rgba(255,200,100,0.5)";
                cacheCtx.fillRect(wx, wy, 3, 6);
                // Occasional neon glow (red/cyan)
                if(seededRand(0,1) < 0.1) {
                  cacheCtx.fillStyle = seededRand(0,1)<0.5 ? "rgba(255,80,120,0.3)" : "rgba(100,200,255,0.3)";
                  cacheCtx.fillRect(wx-1, wy-1, 5, 8);
                }
              }
            }
          }
        }
        
        // Rooftop details
        cacheCtx.fillStyle = "#2a2520";
        cacheCtx.fillRect(0, this.h*0.58, this.w, 8);
        
        // Street line
        cacheCtx.fillStyle = "#3a3530";
        cacheCtx.fillRect(0, this.h*0.68, this.w, 20);
        
        // Smoky atmospheric overlay
        const smokeGrad = cacheCtx.createLinearGradient(0, this.h*0.4, 0, this.h);
        smokeGrad.addColorStop(0, "rgba(0,0,0,0)");
        smokeGrad.addColorStop(1, "rgba(40,30,50,0.15)");
        cacheCtx.fillStyle = smokeGrad;
        cacheCtx.fillRect(0, 0, this.w, this.h);
      }
      
      ctx.save();
      ctx.drawImage(this.noirBackdropCache, 0, 0);
      ctx.restore();
    }

    drawDiscoBackdrop(ctx) {
      ctx.save();
      const grad = ctx.createLinearGradient(0,0,0,this.h);
      grad.addColorStop(0, "rgba(72,12,168,0.7)");
      grad.addColorStop(1, "rgba(3,4,94,0.9)");
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,this.w,this.h);
      ctx.strokeStyle = "rgba(138,196,255,0.3)";
      ctx.lineWidth = 1;
      for(let y=this.h*0.5; y<this.h; y+=25) {
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(this.w,y+20);
        ctx.stroke();
      }
      for(let x=0; x<this.w; x+=40) {
        ctx.beginPath();
        ctx.moveTo(x, this.h*0.5);
        ctx.lineTo(x+30, this.h);
        ctx.stroke();
      }
      ctx.restore();
    }

    drawSpartanBackdrop(ctx) {
      ctx.save();
      const sunGrad = ctx.createRadialGradient(this.w*0.3, this.h*0.35, 10, this.w*0.3, this.h*0.35, 120);
      sunGrad.addColorStop(0, "rgba(255,214,153,0.8)");
      sunGrad.addColorStop(1, "rgba(255,90,60,0)");
      ctx.fillStyle = sunGrad;
      ctx.beginPath();
      ctx.arc(this.w*0.3, this.h*0.35, 120, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(33,0,0,0.5)";
      ctx.beginPath();
      ctx.moveTo(0, this.h*0.75);
      ctx.lineTo(this.w*0.4, this.h*0.45);
      ctx.lineTo(this.w*0.7, this.h*0.7);
      ctx.lineTo(this.w, this.h*0.55);
      ctx.lineTo(this.w, this.h);
      ctx.lineTo(0,this.h);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    drawHellFissures(ctx) {
      ctx.save();
      for(let i=0; i<12; i++) {
        const x = Math.random()*this.w;
        ctx.strokeStyle = "rgba(255,80,0,0.35)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, this.h);
        ctx.lineTo(x + Utils.rand(-40, 40), this.h - Utils.rand(50, 120));
        ctx.stroke();
      }
      ctx.restore();
    }

    loop(now) {
      const dt = Math.min(0.05, (now - this.lastT) / 1000);
      this.lastT = now;

      if (this.crackMode && this.fpsEngine && !this.inCutscene) {
          this.fpsEngine.update(dt);
          this.fpsEngine.draw(this.w, this.h);
      } else {
          if (this.isPaused || (this.dialogOpen && !this.crackMode && !this.inCutscene)) {
            if(this.isPaused) {
               this.pauseTime -= dt;
               this.ui.pauseTimer.innerText = this.pauseTime.toFixed(2);
               if (this.pauseTime <= 0) {
                   this.die();
               }
            }
          } else if (!this.shopOpen && !this.inCutscene) { 
              this.time += dt; 
              this.update(dt); 
          }
          // If we are in cutscene or regular mode, draw 2D
          if(!this.crackMode || this.inCutscene) this.draw();
      }
      
      requestAnimationFrame(this.loop);
    }
  }
  new Game();
})();
</script>
</body>
</html>
